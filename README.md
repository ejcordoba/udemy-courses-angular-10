# Curso de Udemy Angular: De cero a experto (Angular 10+)

Udemy Angular course: From zero to expert (Angular 10+)

## Índice del curso

- [Curso de Udemy Angular: De cero a experto (Angular 10+)](#curso-de-udemy-angular-de-cero-a-experto-angular-10)
  - [Índice del curso](#índice-del-curso)
- [Sección 1:Introducción al curso de Angular](#sección-1introducción-al-curso-de-angular)
  - [5. Instalaciones y configuraciones mínimas necesarias.](#5-instalaciones-y-configuraciones-mínimas-necesarias)
- [Sección 2:Gentil introducción a TypeScript y ES6](#sección-2gentil-introducción-a-typescript-y-es6)
  - [10. Demostración de TypeScript](#10-demostración-de-typescript)
  - [11. Configuración de TypeScript](#11-configuración-de-typescript)
  - [12. Variables let y const](#12-variables-let-y-const)
  - [13. Introducción a los tipos de datos](#13-introducción-a-los-tipos-de-datos)
  - [14. Excluir archivos a traducir](#14-excluir-archivos-a-traducir)
  - [15. Template literales del ES6](#15-template-literales-del-es6)
  - [16. Funciones: Parámetros opcionales, obligatorios y por defecto](#16-funciones-parámetros-opcionales-obligatorios-y-por-defecto)
  - [17. Funciones de Flecha](#17-funciones-de-flecha)
  - [18. Desestructuración de Objetos y Arreglos (arrays)](#18-desestructuración-de-objetos-y-arreglos-arrays)
  - [19. Promesas](#19-promesas)
  - [20. Promesas y su tipado en TypeScript](#20-promesas-y-su-tipado-en-typescript)
  - [21. Interfaces de TypeScript](#21-interfaces-de-typescript)
  - [22. Introducción a las Clases de la POO](#22-introducción-a-las-clases-de-la-poo)
  - [23. Definición de una clase básica en TypeScript](#23-definición-de-una-clase-básica-en-typescript)
  - [24. Constructores de una clase en TypeScript](#24-constructores-de-una-clase-en-typescript)
  - [25. Importaciones * URL](#25-importaciones--url)
  - [26. Decoradores de Clases](#26-decoradores-de-clases)
  - [27. Tipado del retorno de una función](#27-tipado-del-retorno-de-una-función)
  - [28. Exámen práctico #1](#28-exámen-práctico-1)
  - [29. Explicación de la tarea](#29-explicación-de-la-tarea)
  - [30. Resolución del examen práctico #1](#30-resolución-del-examen-práctico-1)
  - [Cuestionario 1: Examen teórico #1](#cuestionario-1-examen-teórico-1)
  - [31. Código fuente de la sección](#31-código-fuente-de-la-sección)
- [Sección 3:Aplicación #1: Hola Mundo](#sección-3aplicación-1-hola-mundo)
  - [35. Introducción a los componentes y directivas estructurales.](#35-introducción-a-los-componentes-y-directivas-estructurales)
  - [36. Nuestra primera interacción en Angular](#36-nuestra-primera-interacción-en-angular)
  - [37. Nota de Actualización del Angular CLI](#37-nota-de-actualización-del-angular-cli)
  - [38. Creando un entorno local de Angular](#38-creando-un-entorno-local-de-angular)
  - [39. Estructura del proyecto](#39-estructura-del-proyecto)
  - [40. Utilizando Bootstrap 4](#40-utilizando-bootstrap-4)
  - [41. TemplateUrl: Separando el HTML del componente](#41-templateurl-separando-el-html-del-componente)
  - [42. Creando el footer.component](#42-creando-el-footercomponent)
  - [43. Estructura del body component](#43-estructura-del-body-component)
  - [44. Directivas estructurales: *ngFor y el *ngIf](#44-directivas-estructurales-ngfor-y-el-ngif)
  - [Cuestionario 2: Examen teórico - de la sección Hola Mundo](#cuestionario-2-examen-teórico---de-la-sección-hola-mundo)
- [Sección 4:Aplicación #2: Aplicación de una sola página (SPA)](#sección-4aplicación-2-aplicación-de-una-sola-página-spa)
  - [49. Iniciar el proyecto - SPA](#49-iniciar-el-proyecto---spa)
  - [50. Creando la estructura de nuestro proyecto](#50-creando-la-estructura-de-nuestro-proyecto)
  - [51. Instalando el bootstrap (u otras liberías de terceros) cuando usamos el Angular-CLI](#51-instalando-el-bootstrap-u-otras-liberías-de-terceros-cuando-usamos-el-angular-cli)
  - [52. Configurando el navbar y otros componentes](#52-configurando-el-navbar-y-otros-componentes)
  - [53. Rutas en Angular](#53-rutas-en-angular)
  - [54. RouterLink y RouterLinkActive - Completando las rutas](#54-routerlink-y-routerlinkactive---completando-las-rutas)
  - [55. Componente Heroes - diseño](#55-componente-heroes---diseño)
  - [56. Introducción a los Servicios](#56-introducción-a-los-servicios)
  - [57. Creando nuestro primer servicio - HeroesService](#57-creando-nuestro-primer-servicio---heroesservice)
  - [58. Página de Heroes - Diseño con *ngFor](#58-página-de-heroes---diseño-con-ngfor)
  - [59. Rutas con parametros - Router](#59-rutas-con-parametros---router)
  - [60. Recibiendo parámetros por URL - ActivatedRoute](#60-recibiendo-parámetros-por-url---activatedroute)
  - [61. Tarea práctica #1 - Componente del héroe](#61-tarea-práctica-1---componente-del-héroe)
  - [62. Resolución de la tarea práctica #1 - Componente del héroe](#62-resolución-de-la-tarea-práctica-1---componente-del-héroe)
  - [63. Pipes: Transformación visual de la data.](#63-pipes-transformación-visual-de-la-data)
  - [64. Buscador de Héroes](#64-buscador-de-héroes)
  - [65. Tarea práctica #2: Crear la pantalla de búsqueda de héroes.](#65-tarea-práctica-2-crear-la-pantalla-de-búsqueda-de-héroes)
  - [66. Resolución de la tarea 2 - Buscador de Héroes.](#66-resolución-de-la-tarea-2---buscador-de-héroes)
  - [67. Plus: Mostrando un mensaje cuando no hay resultados.](#67-plus-mostrando-un-mensaje-cuando-no-hay-resultados)
  - [68. @Input - Recibir información de un componente padre a un hijo.](#68-input-recibir-informaci%C3%B3n-de-un-componente-padre-a-un-hijo)
  - [69. @Output - Emitir un evento del hijo hacia el padre.](#69-output-emitir-un-evento-del-hijo-hacia-el-padre)
  - [70. Arreglar detalles de la búsqueda.](#70-arreglar-detalles-de-la-búsqueda)
- [Sección 5:Pipes - Transforman los valores mostrados en pantalla](#secci%C3%B3n-5-pipes-transforman-los-valores-mostrados-en-pantalla)
  - [72. Introducción a la sección](#72-introducci%C3%B3n-a-la-secci%C3%B3n)
  - [73. ¿Qué aprenderemos en esta sección?](#73-qu%C3%A9-aprenderemos-en-esta-secci%C3%B3n)
  - [74. Demostración del resultado de la sección - Pipes](#74-demostraci%C3%B3n-del-resultado-de-la-secci%C3%B3n-pipes)
  - [75. Inicio del proyecto y la introducción a los Pipes](#75-inicio-del-proyecto-y-la-introducci%C3%B3n-a-los-pipes)
  - [76. Pipe: Slice](#76-pipe-slice)
  - [77. Pipe: Decimal](#77-pipe-decimal)
  - [78. Pipe: Percent - Porcentajes](#78-pipe-percent-porcentajes)
  - [79. Pipe: Currency - Moneda](#79-pipe-currency-moneda)
  - [80. Pipe: Json](#80-pipe-json)
  - [81. Pipe: Async](#81-pipe-async)
  - [82. Pipe: Date - Fecha](#82-pipe-date-fecha)
  - [83. Registrar otros idiomas](#83-registrar-otros-idiomas)
  - [84. Pipes personalizados: Capitalizar palabras](#84-pipes-personalizados-capitalizar-palabras)
  - [85. Pipe Personalizado: Domseguro](#85-pipe-personalizado-domseguro)
  - [86. Tarea de Pipes](#86-tarea-de-pipes)
  - [87. Resolución de la tarea de Pipes](#87-resoluci%C3%B3n-de-la-tarea-de-pipes)
  - [88. Código fuente de la sección](#88-c%C3%B3digo-fuente-de-la-secci%C3%B3n)
- [Sección 6:Aplicación #3: SpotiApp](#secci%C3%B3n-6aplicaci%C3%B3n-3-spotiapp)
  - [89. Introducción a la sección](#89-introducci%C3%B3n-a-la-secci%C3%B3n)
  - [90. ¿Qué aprenderemos en esta sección?](#90-qu%C3%A9-aprenderemos-en-esta-secci%C3%B3n)
  - [91. Demostración del resultado de esta sección](#91-demostraci%C3%B3n-del-resultado-de-esta-secci%C3%B3n)
  - [92. Sitio web de developer de Spotify](#92-sitio-web-de-developer-de-spotify)
  - [93. Iniciando el proyecto - SpotiApp](#93-iniciando-el-proyecto-spotiapp)
  - [94. Creando las rutas de nuestra aplicación](#94-creando-las-rutas-de-nuestra-aplicaci%C3%B3n)
  - [95. Introducción a las peticiones HTTP](#95-introducci%C3%B3n-a-las-peticiones-http)
  - [96. Actualización - Token para uso de servicios Spotify](#96-actualizaci%C3%B3n-token-para-uso-de-servicios-spotify)
  - [97. HTTPClient - Service: Conectándonos a Spotify](#97-httpclient-service-conect%C3%A1ndonos-a-spotify)
  - [98. Consumiendo información del servicio de Spotify](#98-consumiendo-informaci%C3%B3n-del-servicio-de-spotify)
  - [99. Componente de Búsqueda de artistas](#99-componente-de-b%C3%BAsqueda-de-artistas)
  - [100. Operador Map de los Observables](#100-operador-map-de-los-observables)
  - [101. Centralizar las peticiones hacia Spotify](#101-centralizar-las-peticiones-hacia-spotify)
  - [102. Verificación de imagen y pipe para manejar las imágenes](#102-verificaci%C3%B3n-de-imagen-y-pipe-para-manejar-las-im%C3%A1genes)
  - [103. Componente de tarjetas](#103-componente-de-tarjetas)
  - [104. Creando un loading component](#104-creando-un-loading-component)
  - [105. Página del artista, nueva ruta, parámetro por url y servicio](#105-p%C3%A1gina-del-artista-nueva-ruta-par%C3%A1metro-por-url-y-servicio)
  - [106. Obtener artista de Spotify](#106-obtener-artista-de-spotify)
  - [107. Servicio: Top-tracks](#107-servicio-top-tracks)
  - [108. Widgets de Spotify](#108-widgets-de-spotify)
  - [109. Manejo de errores de un observable](#109-manejo-de-errores-de-un-observable)
  - [110. Generar Token de Spotify de forma automática](#110-generar-token-de-spotify-de-forma-autom%C3%A1tica)
  - [Cuestionario 3: Examen teórico: SpotiApp](#cuestionario-3-examen-te%C3%B3rico-spotiapp)
  - [111. Código fuente de la sección](#111-c%C3%B3digo-fuente-de-la-secci%C3%B3n)

# Sección 1:Introducción al curso de Angular

## 5. Instalaciones y configuraciones mínimas necesarias.

**Instalaciones necesarias para el curso**

1. NodeJS: https://nodejs.org/es/
2. Google Chrome:
https://www.google.es/chrome/browser/desktop/
3. TypeScript:
http://www.typescriptlang.org/
4. Angular CLI
https://cli.angular.io/
https://github.com/angular/angular-cli
5. Ionic
http://ionicframework.com/getting-started/

**Editores de Texto:**

Atom
https://atom.io/

Visual Studio Code
https://code.visualstudio.com/

**Plugins recomendados para los siguientes editores:**

**ATOM**

* Angular 2 Type Script Snippets
* Atom Bootstrap3
* Atom Typescript
* File Icons
* Platformio Ide Terminal
* V Bootstrap4

**Visual Studio Code**

* Angular 2 TypeScript Emmet
* Angular 5 Snippets – TypeScript, Html, Angular Material...
* Angular Language Service
* Angular v5 Snippets
* Angular2-inline
* Bootstrap 4 & Font Awesome snippets
* HTML CSS Support
* JavaScript (ES6) code snippets
* JS-CSS-HTML Formatter
* JSHint
* Material Icon Theme
* Prettier – Code Formatter
* Terminal
* TSLint
* TypeScript Hero
* TypeScript Importer

# Sección 2:Gentil introducción a TypeScript y ES6

## 10. Demostración de TypeScript

Explicación de cómo es un lenguaje tipado, para empezar renombramos el archivo app.js a app.ts

Ahora nos muestra errores, la función saludar requería un argumento, que ahora le podemos pasar.

Cuando definimos el argumento a pasar en la función como tipo string y le pasamos el atributo de tipo string del objeto constante nos da un error:

>Uncaught SyntaxError: Unexpected token ':'

Esto es porque el navegador no soporta cargar directamente un archivo tipo .ts que es lo que le estamos indicando en el &lt;script> del html

Para compilar el archivo ts en un archivo js *tsc: typescript compiler* : 

>tsc --version

>Version 3.7.5

>tsc app.ts

[Volver al Índice](#%C3%ADndice-del-curso)

## 11. Configuración de TypeScript

Crear un archivo de configuración:

>tsc --init

Esto genera un archivo tsconfig.json

>tsc -w 

Esto hace que entre en modo observador, pendiente de recompilar cuando haya cambios en el archivo ts

[Volver al Índice](#%C3%ADndice-del-curso)

## 12. Variables let y const

Dentro de un scope (entre llaves), cuando las variables se declaran con *let* tienen validez dentro de ese scope, cuando se declaran dos variables *let* con el mismo nombre, al compilarlas a js se renombran, de tal manera que no hay conflicto.

Por otro lado, se puede declarar un valor como constante, *const*, pero entonces no se le podrá asignar otro valor, la convención es declarar los nombres todos en mayúsculas.

[Volver al Índice](#%C3%ADndice-del-curso)

## 13. Introducción a los tipos de datos

>let mensaje: string = "Hola";

>let numero: number = 123;

>let booleano: boolean = true;

>let hoy: Date = new Date();

>let cualquiercosa;

>//let cualquiercosa: string | number; <-- asignar varios tipos a una misma variable con un pipe

>cualquiercosa = mensaje;

>cualquiercosa = numero;

>cualquiercosa = booleano;

>cualquiercosa = hoy;

```
let spiderman = {
    nombre: 'Peter',
    edad: 30
};
spiderman = {
    nombre: 'Juan',
    edad: 40
};
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 14. Excluir archivos a traducir

Exclusión de archivos a traducir de TS a JS

Creamos un nuevo directorio "typescript" y hacemos una copia del archivo app.ts, renombramos el archivo copiado a tipos.ts

Si entramos en modo observador "tsc -w" también encontrará ese directorio y lo compilará. Pero no lo deseo, porque quiero tipos.ts sólo para mis propias notas.

Vamos a tsconfig.json y añadimos la línea: "exclude": ["demo-typescript/typescript"],

[Volver al Índice](#%C3%ADndice-del-curso)

## 15. Template literales del ES6

```
(function(){

    function getEdad() {
        return 100 + 100 + 300;
    }
    const nombre = "Eduardo";
    const apellido = "Córdoba";
    const edad = 38;
    // const salida = nombre + apellido + edad;
    // const salida = nombre + " " + apellido + " ( " + edad + " ) ";
    // Eduardo Córdoba (Edad: 38)
    const salida = `${ nombre } \n${ apellido } \n( ${ edad + 100 } ) funcion edad= ${getEdad()}`;
    console.log(salida);

})();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 16. Funciones: Parámetros opcionales, obligatorios y por defecto

```
//Función auto-invocada para evitar errores de variables reutilizadas
(function(){
    //quien = argumento obligatorio
    //momento = argumento opcional
    //objeto = argumento por defecto (inicializado con un valor por defecto)
    // El valor por defecto debería ser el último argumento
    function activar( quien: string,
                      momento?: string,
                      objeto:string = 'batiseñal'
                      ) {
        if ( momento ) {
            console.log(`${ quien } activó la ${ objeto } en la ${ momento }`);
        } else {
            console.log(`${ quien } activó la ${ objeto }`);
        }

    }
    activar('Gordon','tarde');
})();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 17. Funciones de Flecha

```
//Función auto-invocada para evitar errores de variables reutilizadas
(function(){

    // Si declaramos la función en una constante no podremos sobreescribir la declaración de la función
    const miFuncion = function( a: string) {
        return a.toUpperCase();
    }
    //La misma función en versión "Función de flecha", si sólamente se va a retornar una línea de código se pueden ahorrar las llaves y el return
    const miFuncionF = ( a: string ) =>  a.toUpperCase();


    const sumarN = function( a:number, b:number) {
        return a + b;
    }
    const sumarF = ( a:number, b:number ) => a + b;
    console.log( sumarN (8,3) );
    console.log( sumarF (5,5) );

    const hulk = {
        nombre: 'Hulk',
        smash() {
            //setTimeout para ejecutar una función tras un tiempo(en milésimas de segundo)
            //Las funciones de flecha (setTimeout( ()=>)) no modifican a lo que apunta "this", this apunta a "const hulk"
            setTimeout( ()=> {

                console.log(`${ this.nombre } smash!!!`);

            }, 1000);
        }
    }
    //console.log( miFuncion('Normal') );
    //console.log( miFuncionF('Flecha') );

    hulk.smash();
})();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 18. Desestructuración de Objetos y Arreglos (arrays)

```
//Función auto-invocada de flecha para evitar errores de variables reutilizadas
(()=>{
    //objeto
    const avenger = {
       nombre: 'Steve',
       clave: 'Capitan América',
       poder: 'Droga'
    }
    //extraer propiedades
    /* console.log( avenger.nombre );
    console.log( avenger.clave );
    console.log( avenger.poder ); */
    //coger el objeto avenger y extraer todas sus propiedades, en este tipo de desestructuración no importa el orden
   /*  const {nombre, poder} = avenger;
    console.log( nombre );
    console.log( poder ); */
    //También funciona en los argumentos de una función
    /* const extraer = ( avenger: any ) => {
        const {nombre, poder} = avenger;
        console.log( nombre );
        console.log( poder );
    }
    extraer ( avenger ); */
    //Podemos pasarle directamente las propiedades extraídas
    const extraer = ( { nombre, poder }: any ) => {
        //const {nombre, poder} = avenger;
        console.log( nombre );
        console.log( poder );
    }
    //extraer ( avenger );
    //Desestructuración de arrays


    //Sin desestructurar:
    const avengers: string[] = ['Thor','Ironman','Spiderman'];
    console.log( avengers[0] );
    console.log( avengers[1] );
    console.log( avengers[2] );
    //Con desestructuración: puedo definir las variables en orden de suposición, con un objeto no es necesario, pero con un array si
    // const [ loki, hombre, arana] = avengers;
    //Si solo queremos un valor dejamos el resto vacío separados con comas
    //const [ , , arana] = avengers;
    /* console.log( loki );
    console.log( hombre ); */
    //console.log( arana );
    const extraerArr = ( [thor,ironman,spiderman]: string[]) => {
            console.log( thor );
            console.log( ironman );
            console.log( spiderman );
    }
    extraerArr(avengers);
})();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 19. Promesas

```
//Función auto-invocada de flecha para evitar errores de variables reutilizadas
(()=>{
//Las promesas, básicamente, nos sirven para ejecutar un código sin bloquear el código de la aplicación

    console.log('Inicio');
//Si definimos la promesa así nos da un error porque le falta una libreria, así que en el tsconfig.json tenemos que cambiar de es5 al es6
//'Promise' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the `lib` compiler option to es2015 or later.ts(2585)
//Dentro de la promesa necesito mandar una función que lleve dos argumentos, dentro de esos argumentos necesito mandar dos funciones
//Una que se va a llamar usualmente "resolve", que es lo que vamos a retornar cuando todo funciona correctamente
//Y otra que se va a llamar "reject", que llamaremos si sucede algún error
    const prom1 = new Promise( ( resolve, reject) => {

        setTimeout(() => {
            //resolve('Se terminó el timeout');
            //Si ejecutamos el código aparecerá el console.log inicio, luego ejecutará la promesa, pero como tiene un retraso de 1 segundo no interrumpe el código, ejecuta el console.log de fin y luego aparece el mensaje de prom1
            reject('Se terminó el timeout');
            //Si ejecutamos el código aparecerá el console.log inicio, luego ejecutará la promesa, pero como tiene un retraso de 1 segundo no interrumpe el código, ejecuta el console.log de fin y luego aparece el error (sin atrapar, sin catch) de prom1
        }, 1000);

    });
    //Llamamos a la promesa prom1, tenemos tres opciones: Symbol, catch y then, Symbol es un identificador
    //Then es lo que yo quiero ejecutar cuando se realiza todo exitosamente y catch cuando sucede un error
    prom1
        .then( mensaje => console.log( mensaje ))
        .catch( err => console.warn(err));//console.warn se muestra en amarillo
    console.log('Fin');
})();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 20. Promesas y su tipado en TypeScript
```
//Función auto-invocada de flecha para evitar errores de variables reutilizadas
(()=>{
    //Para definir el tipo (tipado) de retorno de las promesas, vamos a definirlo tras los argumentos, indicando entre <> que tipo si hace el resolve (correcto)
    //:Promise<number>
    //
    const retirarDinero = ( montoRetirar: number): Promise<number> => {
        //Suponiendo que la cantidad de dinero esté en un backend, en un servidor, y se tiene que retirar de manera asíncrona, porque tengo que verificar
        //si en el servidor tengo esa cantidad de dinero, entonces la tarea se podría retrasar unos segundos
        let dineroActual = 1000;
        //Retirar dinero devolverá una promesa
        return new Promise( (resolve,reject) =>{

            if ( montoRetirar > dineroActual ) {
                reject('No hay suficientes fondos');
            } else {
                //dineroActual = dineroActual - montoRetirar; Siguiente línea version corta de esta línea de código
                dineroActual -= montoRetirar;
                //Una vez hecho el cálculo hago el resolve, no es obligatorio retornar algo, pero en este caso vamos a retornar el monto actual
                resolve( dineroActual );
            }
        } );
    }

    //Para poder manejar la promesa tenemos que especificar en la función el then o el catch
    retirarDinero( 500 )
        .then( montoActual => console.log(`Me queda ${ montoActual}`))
        //.catch( err => console.warn (err)); a continuación versión corta, porque solo estoy usando esa variable ahí
        .catch ( console.warn )
})();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 21. Interfaces de TypeScript

```
//Función auto-invocada de flecha para evitar errores de variables reutilizadas
(()=>{

    //Interfaces: Reglas que queremos que cumpla un objeto para que pueda usarse como un tipo
    //Es como crear un tipo de dato "tonto", no se pueden definir la funcionalidad de los métodos internamente
    //Son manera de definir reglas para que nosotros u otros compañeros sigan si quieren usar un tipo

    interface Xmen {//no hay código equivalente en js, cuando se compila no aparece nada en el .js, son puramente para ts
        nombre: string;
        edad: number;
        poder?: string;//Declarando la variable con ?: especificamos que esta variable es opcional
    }
    const enviarMision = ( xmen: Xmen ) => {//definido como tipo de interfaz customizada anteriormente

        console.log(`Enviando a ${ xmen.nombre } a la misión`);

    }

    const regresarAlCuartel = ( xmen: Xmen ) => {

        console.log(`Enviando a ${ xmen.nombre } a la misión`);

    }

    const wolverine: Xmen = {//Definiendo el interfaz a la hora de declarar el objeto me aseguro que se cumplan las condiciones de tipado
        nombre: 'Logan',
        edad: 60
    }
    enviarMision( wolverine );
    regresarAlCuartel( wolverine );

})();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 22. Introducción a las Clases de la POO

>Controlado, pasando lección.

[Volver al Índice](#%C3%ADndice-del-curso)

## 23. Definición de una clase básica en TypeScript

```
//Función auto-invocada de flecha para evitar errores de variables reutilizadas
(()=>{

    //Convención de nombres de clases, capitalizar palabras
    class Avenger {
        //Nombre: tipo
        nombre: string = "Sin nombre";
        equipo: string;
        nombreReal: string; //lowercamelcase

        puedePelear: boolean;
        peleasGanadas: number;

    }

    const antman = new Avenger();

    console.log(antman);
})();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 24. Constructores de una clase en TypeScript
```
//Función auto-invocada de flecha para evitar errores de variables reutilizadas
(()=>{

    //Convención de nombres de clases, capitalizar palabras
    class Avenger {
        //Nombre: tipo
       /*  nombre: string;
        equipo: string;
        nombreReal: string; //lowercamelcase

        puedePelear: boolean;
        peleasGanadas: number; */

        //Constructor: función que se ejecuta cuando se crea una nueva instancia de una clase
        /* constructor( nombre: string , equipo: string){
            this.nombre = nombre; //this apunta a la propiedad nombre de la clase Avenger, y será igual al valor que se le pasa al constructor
            this.equipo = equipo;

        } */
        constructor( public nombre: string,
                     public equipo: string,
                     public nombreReal?: string,
                     public puedePelear: boolean = true,
                     public peleasGanadas: number = 0){}//public: acceso desde la clase o fuera de la misma

    }

    const antman = new Avenger('Antman','Capi');

    console.log(antman);
})();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 25. Importaciones * URL

Descargamos el código de ejemplo de la lección: https://github.com/Klerith/webpack-starter-typescript

Dentro del directorio ejecutamos "npm install"

Posteriormente ejecutamos el index.ts con "npm start"

Creamos dentro del directorio src un nuevo directorio llamado "classes" o un nombre a nuestra elección, dentro de él creamos un archivo llamado "xmen.class.ts", el nombre .class. es opcional pero es una convencción opcional (alguna gente lo considera redundante)

Básicamente, para exportar una clase(xmen.class.ts):

```
export class Xmen {
    constructor(
        public nombre: string,
        public clave : string
    ){}

    imprimir() {
        console.log(`${ this.nombre } - ${ this.clave}`);
    }
}
```
Para importarla (index.ts):

```
import { Xmen } from './classes/xmen.class';

const wolverine = new Xmen('Logan','Wolverine');

wolverine.imprimir();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 26. Decoradores de Clases
```
function imprimirConsola( constructorClase: Function) {
    console.log( constructorClase );
}//Para recibir el constructor de la función, o firma de la clase
//Un decorador es algo que se le va a colocar (en este caso decorador de clase) antes de la definición de la clase
@imprimirConsola //<-- Decorador, tenemos que configurar en el tsconfig.json para que lo acepte: "experimentalDecorators": true
//El decorador permite añadir funcionalidades a la clase. Una función que se ejecuta en las clases, expandiendo su funcionalidad
export class Xmen {
    constructor(
        public nombre: string,
        public clave : string
    ){}

    imprimir() {
        console.log(`${ this.nombre } - ${ this.clave}`);
    }
}
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 27. Tipado del retorno de una función
```
//Función auto-invocada de flecha para evitar errores de variables reutilizadas
(()=>{

    const sumar = (a: number, b: number): number =>  a + b;   
    
    const nombre = (): string => 'Hola Fernando';

    const obtenerSalario = ():Promise<string> => {

        return new Promise ( (resolve, reject) => {
            resolve('Fernando')
        });
    }

    obtenerSalario().then( a => console.log( a.toUpperCase() ) )
})();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 28. Exámen práctico #1

Instrucciones
Descargue el material adjunto, el cual es un archivo de TypeScript.

Se requiere que sea lo más especifico posible en cuanto a los tipos y uso de lo aprendido en esta sección (como es el ES6)

Sea lo más explícito posible y siga las instrucciones que se encuentran en los comentarios del mismo.

Por si acaso tienen problemas con la descarga (por alguna razón) Les dejo aquí el código

Lean todos los comentarios y vean el siguiente video

[Volver al Índice](#%C3%ADndice-del-curso)

## 29. Explicación de la tarea

> Ver vídeo

[Volver al Índice](#%C3%ADndice-del-curso)

## 30. Resolución del examen práctico #1

```
(()=>{

  // Uso de Let y Const
  const nombre = 'Ricardo Tapia';
  const edad = 23;

  /* const PERSONAJE = {
    nombre: nombre,
    edad: edad
  };Si una propiedad tiene el mismo valor que una variable (nombre:nombre), como este caso, se puede definir como a continuación*/
  const PERSONAJE = { nombre, edad };


  // Cree una interfaz que sirva para validar el siguiente objeto
  interface Batman  {
    nombre: string;
    artesMarciales: string[];
  }

  const batman: Batman = {
    nombre: 'Bruno Díaz',
    artesMarciales: ['Karate','Aikido','Wing Chun','Jiu-Jitsu']
  }


  // Convertir esta funcion a una funcion de flecha
  /* function resultadoDoble( a, b ){
    return (a + b) * 2
  } */
  const resultadoDoble = ( a: number, b: number):number => {
    return (a + b) *2
  }


  // Función con parametros obligatorios, opcionales y por defecto
  // donde NOMBRE = obligatorio
  //       PODER  = opcional
  //       ARMA   = por defecto = 'arco'
  function getAvenger( nombre:string, poder?:string, arma:string = 'arco' ){
    let mensaje;
    if( poder ){
      mensaje = nombre + ' tiene el poder de: ' + poder + ' y un arma: ' + arma;
    }else{
      mensaje = nombre + ' tiene un ' + poder
    }
  };

  // Cree una clase que permita manejar la siguiente estructura
  // La clase se debe de llamar rectangulo,
  // debe de tener dos propiedades:
  //   * base
  //   * altura
  // También un método que calcule el área  =  base * altura,
  // ese método debe de retornar un numero.
class Rectangulo {
  constructor ( public base:number,
                public altura:number ){}

  calcularArea = ():number => this.base * this.altura;

}
})();
```

[Volver al Índice](#%C3%ADndice-del-curso)

## Cuestionario 1: Examen teórico #1

> Resuelto / Aprobadas 9 de 10

[Volver al Índice](#%C3%ADndice-del-curso)

## 31. Código fuente de la sección

> Descargar typescript.zip

[Volver al Índice](#%C3%ADndice-del-curso)

# Sección 3:Aplicación #1: Hola Mundo

## 35. Introducción a los componentes y directivas estructurales.

- Componentes: Pequeñas clases que cumplen una tarea específica, por ejemplo: Menú de navegación, Barra Lateral, Páginas, sub-páginas...footer...

- Directivas estructurales: Instrucciones que indical al HTML qué hacer, *ngIf por ejemplo para mostrar o no contenedores, etc ... *ngFor para hacer repeticiones de elementos HTML

[Volver al Índice](#%C3%ADndice-del-curso)

## 36. Nuestra primera interacción en Angular

> Visitar https://angular.io

- Cuando buscamos en la web nos aparecen informaciones con un icono delante que representa:
- Pk: Package
- C: Clase
- I: Interfaz
- K: Constante
- F: Función
- E: Enumeración
- P: Pipe

> Visitar https://plnkr.co/ Que se usará para códigos de demostración
> También https://stackblitz.com/

Usando este último crearemos un nuevo proyecto de Angular para testeo.

[Volver al Índice](#%C3%ADndice-del-curso)

## 37. Nota de Actualización del Angular CLI

> Al hacer ng new miApp ahora Angular CLI hace dos preguntas:

- Would you like to add Angular routing? No -> Nosotros haremos nuestras propias rutas
- Which stylesheet format would you like to use? CSS (a elegir entre CSS, SCSS, SASS, LESS, Stylus)

[Volver al Índice](#%C3%ADndice-del-curso)

## 38. Creando un entorno local de Angular

- https://angular.io/guide/quickstart
- Angular CLI
> ng new my-app
> ng serve -o 

- app.compontent.html:
```
<h1>Hola Mundo</h1>

<ul>
    <li>Nombre: {{ nombre }}</li>
    <li>Apellido: {{ apellido }}</li>
</ul>
```
- app.component.ts:
```
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  nombre = 'Fernando';
  apellido = 'Herrera';
}

```

[Volver al Índice](#%C3%ADndice-del-curso)

## 39. Estructura del proyecto

- e2e: Test end to end, pruebas unitarias, integración, pruebas automáticas
- node_modules: módulos de node.js
- src: aplicación de Angular
    - app
        - Primera aplicacion de angular
            - app.component.ts: primer componente
            - app.component.css: archivo de estilo que sólo se aplica a este componente
            - app.component.html: html del componente
            - app.component.spec.ts: Archivo de pruebas automáticas (todo archivo "spec")
            - app.module.ts.
    - assets: Recursos estáticos, imágenes, etc...
    - enviroments:
        - enviroment.prod.ts: Variable de ambiente de producción
        - enviroment.ts: Variable de ambiente de desarrollo
    - browserslist: lista de navegadores para consolidación de CSS
    - karma.conf.js: archivo de configuración de las pruebas de karma
    - main.js: Primer código que Angular ejecutará para lanzar la aplicación
        - platformBrowserDynamic(): Es una función que configura todo el ambiente para una aplicación web
    - polyfills.ts: Funciones que ayudan a la compatibilidad entre versiones antiguas de navegadores web
    - styles.css: CSS global de la aplicación
    - index.html: Toda la aplicación se renderiza en <app-root>
    - tsconfig.app.json: Especificaciones propias de la aplicacion de typescript
    - tsconfig.spec.json: Configuración para las pruebas
    - tslint.json: formas para la presentación de errores de código
- .editorconfig: configuración del editor
- .gitignore: ignorar archivos para el repositorio
- angular.json: configuración de la aplicación
- package-lock.json: nos dice como fué creado package.json
- package.json: dependencias de producción, de desarrollo
- README.md: cómo funciona la aplicación, archivo Markdown
- tsconfig.json: le dice a typescript cómo trabajar
- tslint.json: reglas de escritura

[Volver al Índice](#%C3%ADndice-del-curso)

## 40. Utilizando Bootstrap 4

> https://getbootstrap.com/ -> Download
```
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">

```

- Creación manual de un componente:

    - app/components/header/header.component.ts

- Indicar a la aplicación la creación del componente:
    - app/app.module.ts

- app.module.ts:
```
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { AppComponent } from './app.component';
import { HeaderComponent } from './components/header/header.component';
@NgModule({
  declarations: [// Declarar componentes
    AppComponent,
    HeaderComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```
- app.component.html
```
<app-header></app-header>

<ul>
    <li>Nombre: {{ nombre }}</li>
    <li>Apellido: {{ apellido }}</li>
</ul>
```
- header.component.ts
```
import { Component } from '@angular/core';

/* Declaramos decorador para indicar que la clase HeaderComponen instanciará un componente */
@Component({
    selector: 'app-header', // Para llamar al componente mediante etiqueta en el html
    template: `<h1>Header component</h1>` // HTML que se mostrará, o bien código directamente si es poco, o bien llamada a la plantilla HTML
})
export class HeaderComponent { // indicamos export para poder llamarlo en app.module.ts

}
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 41. TemplateUrl: Separando el HTML del componente

Vamos a https://getbootstrap.com/ -> Buscamos el navbar

Copiamos el código HTML del navbar y lo incluimos en el template del componente en header.component.ts

```
import { Component } from '@angular/core';

/* Declaramos decorador para indicar que la clase HeaderComponen instanciará un componente */
@Component({
    selector: 'app-header', // Para llamar al componente mediante etiqueta en el html
    template: `
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
  <a class="navbar-brand" href="#">Navbar</a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <ul class="navbar-nav mr-auto">
      <li class="nav-item active">
        <a class="nav-link" href="#">Home <span class="sr-only">(current)</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="#">Link</a>
      </li>
      <li class="nav-item dropdown">
        <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
          Dropdown
        </a>
        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
          <a class="dropdown-item" href="#">Action</a>
          <a class="dropdown-item" href="#">Another action</a>
          <div class="dropdown-divider"></div>
          <a class="dropdown-item" href="#">Something else here</a>
        </div>
      </li>
      <li class="nav-item">
        <a class="nav-link disabled" href="#" tabindex="-1" aria-disabled="true">Disabled</a>
      </li>
    </ul>
    <form class="form-inline my-2 my-lg-0">
      <input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search">
      <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
    </form>
  </div>
</nav>
    `
})
export class HeaderComponent { // indicamos export para poder llamarlo en app.module.ts

}
```

tslint nos avisará de que incluir todo ese código directamente excede el máximo permitido, esto se puede ajustar cambiando el parámetro max-line-length en tslint.json

Podemos tanto cambiar el máximo permitido, como desactivar el warning poniendo la propiedad en "false"

```
"max-line-length": [
      false,
      140
    ],
```
De todas maneras, como hemos comentado, cuando en template el código supera unas cuatro líneas empieza a no ser manejable, así que es recomendable crear un archivo template aparte:

> app/components/header/header.component.html

Aquí copiamos todo el código HTML del navbar

En el decorador del componente tenemos que eliminar el código que teníamos en template, y renombrar template como templateUrl para especificar la ruta a la plantilla html que hemos creado

Crearemos también un body de la misma manera, a la misma etiqueta html de componente podemos añadirle estilos, de esta manera

><app-body class="container"></app-body>

Recordar añadir los componentes al módulo de app (app.module.ts):

```
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { AppComponent } from './app.component';
import { HeaderComponent } from './components/header/header.component';
import { BodyComponent } from './components/body/body.component';
@NgModule({
  declarations: [// Declarar componentes
    AppComponent,
    HeaderComponent,
    BodyComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 42. Creando el footer.component

En este caso vamos a usar angularCLI para crear el componente

>ng g c components/footer

Esto es la abreviatura de:

>ng generate component components/footer
```
$ ng g c components/footer
CREATE src/app/components/footer/footer.component.html (21 bytes)
CREATE src/app/components/footer/footer.component.spec.ts (628 bytes)
CREATE src/app/components/footer/footer.component.ts (275 bytes)
CREATE src/app/components/footer/footer.component.css (0 bytes)
UPDATE src/app/app.module.ts (627 bytes)
```

Una vez generado ya tenemos todos los archivos, incluidas las importaciones en app.module.ts

Entonces podemos añadir código al footer.component.html:

```
<footer class="footer bg-dark text-center">
    <div class="container">
        <p>
            &copy; Eduardo Córdoba 2020
        </p>
    </div>
</footer>
```

Y llamar al componente en app.component.html:

```
<app-header></app-header>

<app-body class="container"></app-body>

<app-footer></app-footer>
```

Para posicionar el componente abajo en la web, usamos estilos CSS, al ser un estilo común es recomendable hacerlo en src/styles.css

```
footer {
  color: white;
  position: fixed;
  bottom: 0;
}
```

Vamos a hacer que en el footer se visualice el año actual automáticamente, para eso usaremos la función Date() de JavaScript, declaramos la variable anio y en el constructor la inicializamos con la función que devuelve el año actual, de tal manera que cuando se cargue la aplicación y este componente, en el HTML aparecerá ese valor, será de la siguiente manera, en footer.component.ts:

```
import { Component } from '@angular/core';

@Component({
  selector: 'app-footer',
  templateUrl: './footer.component.html',
  styleUrls: ['./footer.component.css']
})
export class FooterComponent {
  anio: number;

  constructor() {
    this.anio = new Date().getFullYear();
  }

}
```

En footer.component.html:

```
<footer class="footer bg-dark text-center">
    <div class="container">
        <p>
            &copy; {{ anio }} Eduardo Córdoba
        </p>
    </div>
</footer>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 43. Estructura del body component

Vamos a https://getbootstrap.com/ -> Buscamos cards y cogemos un código tipo este:

```
<div class="card text-white bg-primary mb-3" style="max-width: 18rem;">
  <div class="card-header">Header</div>
  <div class="card-body">
    <h5 class="card-title">Primary card title</h5>
    <p class="card-text">Some quick example text to build on the card title and make up the bulk of the card's content.</p>
  </div>
</div>
```

Vamos a https://getbootstrap.com/ -> Buscamos list group y cogemos un código tipo este:

```
<ul class="list-group">
            <li class="list-group-item">Cras justo odio</li>
            <li class="list-group-item">Dapibus ac facilisis in</li>
            <li class="list-group-item">Morbi leo risus</li>
            <li class="list-group-item">Porta ac consectetur ac</li>
            <li class="list-group-item">Vestibulum at eros</li>
        </ul>
```

Modificamos y ajustamos el estilo del app.component.html para que reciba los nuevos elementos, algo así:

```
<app-header></app-header>

<div class="container mt-5">
    <app-body></app-body>
</div>

<app-footer></app-footer>
```

Y quedaría el body.component.html tal que:

```
<div class="row">
    <div class="col">
        <h1>*ngIf</h1>
        <hr>
        <div class="card text-white bg-primary mb-3" style="width: 100%;">
            <div class="card-body">
                <h5 class="card-title">Primary card title</h5>
                <p class="card-text">Some quick example text to build on the card title and make up the bulk of the card's content.</p>
            </div>
        </div>
        <button class="btn btn-outline-primary btn-block">Mostrar/Ocultar</button>
    </div>
    <div class="col">
        <h1>*ngFor</h1>
        <hr>
        <ul class="list-group">
            <li class="list-group-item">Cras justo odio</li>
            <li class="list-group-item">Dapibus ac facilisis in</li>
            <li class="list-group-item">Morbi leo risus</li>
            <li class="list-group-item">Porta ac consectetur ac</li>
            <li class="list-group-item">Vestibulum at eros</li>
        </ul>
    </div>
</div>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 44. Directivas estructurales: *ngFor y el *ngIf

Vamos a usar estas directivas para generar dinámicamente código HTML en nuestros elementos del body component

Creamos un objeto con dos atributos tipo string:

```
export class BodyComponent { // indicamos export para poder llamarlo en app.module.ts

    frase: any = {
        mensaje: 'Un gran poder requiere una gran responsabilidad',
        autor: 'Ben Parker'
    };
}
```

Y luego las llamamos en el html tipo {{ objeto.atributo }}

```
<div class="card-body">
                <h5 class="card-title"> {{ frase.autor }} </h5>
                <p class="card-text"> {{ frase.mensaje }} </p>
            </div>
```

Ahora usaremos *ngIf para mostrar u ocultar la tarjeta, para ello declaramos una variable booleana que haga de bandera en el componente:

```
export class BodyComponent { // indicamos export para poder llamarlo en app.module.ts

    mostrar = true;
```

Y añadimos la condición *ngIf al elemento que queremos manipular, además de en el boton añadir un evento (click) que vaya alternando el valor de la bandera de true a false y viceversa:

```
 <div *ngIf="mostrar" class="card text-white bg-primary mb-3" style="width: 100%;">
            <div class="card-body">
                <h5 class="card-title"> {{ frase.autor }} </h5>
                <p class="card-text"> {{ frase.mensaje }} </p>
            </div>
        </div>
        <button (click)="mostrar = !mostrar" class="btn btn-outline-primary btn-block">Mostrar/Ocultar</button>
```

Y ahora para usar el *ngFor y generar la lista dinámicamente primero creamos un array de string en el componente:

```
export class BodyComponent { // indicamos export para poder llamarlo en app.module.ts

    mostrar = true;
    frase: any = {
        mensaje: 'Un gran poder requiere una gran responsabilidad',
        autor: 'Ben Parker'
    };

    personajes: string[] = ['Spiderman', 'Venom', 'Dr. Octopus'];
}
```

Y posteriormente lo llamamos, aprovechamos tambien para guardar el index y usarlo para puntuar numéricamente la lista:

```
<ul class="list-group">
            <li *ngFor="let personaje of personajes; let i = index" class="list-group-item">
                {{ i +1 }} - {{ personaje }}
            </li>
        </ul>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## Cuestionario 2: Examen teórico - de la sección Hola Mundo

10 de 10 !!!

[Volver al Índice](#%C3%ADndice-del-curso)

# Sección 4:Aplicación #2: Aplicación de una sola página (SPA)

¿Qué veremos en esta sección?

A continuación vamos a aprender sobre los siguientes temas:

- Crearemos una aplicación de una sola página (Single Page Application)
- Creación de proyectos de Angular usando el CLI (Command Line Interface)
- Instalando bootstrap o librerías de terceros usando el Angular-CLI
- Creación de rutas de nuestra aplicación
- Uso de RouterLink y RouterLinkActive para movernos de página y colocar clases a los elementos activos.
- Uso del modulo Router, que nos permite movernos de página mediante código.
- Obtención de parámetros vía URL.
- Configuración de nuestro primer servicio en Angular para el manejo de la data.
- Breve introducción a los Pipes 
- Uso del buscador del navbar para realizar una consulta a nuestro arreglo de héroes.
- Durante la sección, tendremos una tarea práctica bastante retadora pero servirá de reforzamiento de todo lo que veremos en esta sección.

[Volver al Índice](#%C3%ADndice-del-curso)

## 49. Iniciar el proyecto - SPA

Sencillamente creamos el nuevo proyecto con:

>ng new spa

Para luego renombrar la carpeta "spa" a 02-spa, y entrando en ella lanzar el proyecto con:

>ng serve -o

[Volver al Índice](#%C3%ADndice-del-curso)

## 50. Creando la estructura de nuestro proyecto

Básicamente creamos dos componentes para empezar, uno para la home y otro que sea un navbar que se encuentre en un subdirectorio de componentes compartidos (comunes) a la SPA

>ng g c components/shared/navbar

>ng g c components/home

Y limpiamos cosas que no queremos, archivos css y spec

[Volver al Índice](#%C3%ADndice-del-curso)

## 51. Instalando el bootstrap (u otras liberías de terceros) cuando usamos el Angular-CLI

1. Instalando el Boostrap CDN (requiere internet)(normalmente ya se encontrará en el caché del navegador del cliente)

```
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>
```
```
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" integrity="sha384-w1Q4orYjBQndcko6MimVbzY0tgp4pWB4lZ7lr30WKz0vr/aWKhXdBNmNb5D92v7s" crossorigin="anonymous"></script>
```

Los scripts deberemos colocarlos al final del body, y el link al final del head

2. Instalación local: Descarga directa de bootstrap

https://getbootstrap.com/docs/4.5/getting-started/download/

Creamos en nuestro proyecto la ruta src/assets/libs/dist y dentro copiamos los directorios css y js que hemos descargado

Puede tener la formación de rutas que sea, pero que esté dentro de assets

Se debería repetir esto con todas las librerias que se refirieron en el punto 1, y luego referenciarlas con rutas relativas tipo:

```<link rel="stylesheet" href="./assets/libs/bootstrap/css/bootstrap.min.css">```

3. Instalación con el Gestor de Paquetes de Node.js (npm)

>npm install bootstrap --save

Una vez terminado tendremos bootstrap dentro de node_modules

Hacer lo mismo para jquery y popper.js

>npm install jquery --save

>npm install popper.js --save

(Nota: Esto puede haber cambiado en las últimas versiones de Angular.....)

Ahora habría que especificar en angular.json donde está el css de bootstrap y las librerías javascript a utilizar:

```
                        "styles": [
                            "src/styles.css",
                            "node_modules/bootstrap/dist/css/bootstrap.min.css"
                        ],
                        "scripts": [
                            "node_modules/jquery/dist/jquery.slim.min.js",
                            "node_modules/popper.js/dist/umd/popper.min.js",
                            "node_modules/bootstrap/dist/js/bootstrap.min.js"
                        ]
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 52. Configurando el navbar y otros componentes

Copiamos los archivos de imágenes del curso en assets/img

Copiamos el favicon.ico en src/

Usamos template de bootstrap para definir el navbar.component.html:

```
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <a class="navbar-brand" href="#">
        <img src="assets/img/A-64.png" width="30" height="30" alt="" loading="lazy">
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item active">
                <a class="nav-link" href="#">Home</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="#">Link</a>
            </li>
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
          Dropdown
        </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item" href="#">Action</a>
                    <a class="dropdown-item" href="#">Another action</a>
                    <div class="dropdown-divider"></div>
                    <a class="dropdown-item" href="#">Something else here</a>
                </div>
            </li>
        </ul>
        <form class="form-inline my-2 my-lg-0">
            <input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search">
            <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
        </form>
    </div>
</nav>
```

Usamos template de bootstrap para definir el home.component.html:

```
<div class="jumbotron jumbotron-fluid">
    <div class="container">
        <h1 class="display-4">Comic App</h1>
        <p class="lead">Esta es una aplicación de comics.</p>
    </div>
</div>
```

Llamamos a los componentes en el app.component.html

```
<app-navbar></app-navbar>
<app-home></app-home>
```

Instalamos un par de componentes más: about y heroes, este ultimo lo vamos a crear sin archivo de estilos "-is" (inline style)

> ng g c components/about

> ng g c components/heroes -is

[Volver al Índice](#%C3%ADndice-del-curso)

## 53. Rutas en Angular

Las rutas nos permiten navegar por los diferentes componentes (páginas) sin hacer refresh del navegador

Creamos un nuevo archivo en src/app/app.routes.ts (el nombre es una convención), tiene una sintaxis particular:

si tenemos snippets instalados con escribir ng2routes y pulsar enter se nos genera el código, sino tendríamos que escribir:

```
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './components/home/home.component';

const APP_ROUTES: Routes = [ // Array de rutas, cada ruta tiene un path y un componente
    { path: 'home', component: HomeComponent },
    { path: '**', pathMatch: 'full', redirectTo: 'home' } // La ruta ** es una ruta especial por si no consigue hacer match con ninguna de las otras
];

export const APP_ROUTING = RouterModule.forRoot(APP_ROUTES);
// Si enviamos parámetros por url y hacemos refresh puede fallar, entonces usaríamos el sistema de hash en la URL
// Para usar el sistema de hash en la URL sería:
// export const APP_ROUTING = RouterModule.forRoot(APP_ROUTES, { useHash: true});
// De otro modo tendríamos que indicar en el servidor, con .htaccess por ejemplo, que redirija a la raíz.
// De manera automática nos configuró angular-cli en el index.html <base href="/"> necesario si no vamos a usar hash.
```

Para indicar a Angular las rutas que tiene que usar, tenemos que definirlo en app.module.ts:

```
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
// Rutas
import { APP_ROUTING } from './app.routes'; // Importamos el sistema de rutas
// Servicios

// Componentes
import { AppComponent } from './app.component';
import { NavbarComponent } from './components/shared/navbar/navbar.component';
import { HomeComponent } from './components/home/home.component';
import { AboutComponent } from './components/about/about.component';
import { HeroesComponent } from './components/heroes/heroes.component';

@NgModule({
  declarations: [
    AppComponent,
    NavbarComponent,
    HomeComponent,
    AboutComponent,
    HeroesComponent
  ],
  imports: [
    BrowserModule,
    APP_ROUTING // Añadimos el routing a los imports
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 54. RouterLink y RouterLinkActive - Completando las rutas

Y en nuestro html los enlaces quedarán así en navbar.component.html:
```
<div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav mr-auto">
            <!-- Class active para marcar enlace activo -->
            <li class="nav-item">
                <a class="nav-link" [routerLink]="['home']">Home</a> <!-- Para definir la ruta usarmos router link en lugar de href de html
                usa un array como parámetro, cada uno de los elementos del array serían las sub-rutas de la url -->
            </li>
            <li class="nav-item">
                <a class="nav-link" [routerLink]="['heroes']">Heroes</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" [routerLink]="['about']">About</a>
            </li>
        </ul>
        <form class="form-inline my-2 my-lg-0">
            <input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search">
            <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
        </form>
    </div>
```

Hemos añadido algunos efectos de transición en el archivo styles.css

También añadimos la clase especial <li class ="nav-item" routerLinkActive="active"> para asignar los enlaces activos.

Como el <a> tiene un routerLink mira el elemento padre y al detecar routerLinkActive aplica la clase "active" (podría ser otra)

[Volver al Índice](#%C3%ADndice-del-curso)

## 55. Componente Heroes - diseño

Para la sección heroes usaremos cards de Bootstrap, de momento usaremos una ruta estática, pero en la siguiente lección usaremos servicios:

```
<h1>Héroes <small>Marvel y DC</small></h1>
<hr>

<div class="card-columns">
    <div class="card">
        <img src="assets/img/aquaman.png" class="card-img-top" alt="...">
        <div class="card-body">
          <h5 class="card-title">Card title</h5>
          <p class="card-text">This card has supporting text below as a natural lead-in to additional content.</p>
          <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p>
          <button type="button" class="btn btn-outline-primary btn-block">
              Ver más...
          </button>
        </div>
    </div>
</div>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 56. Introducción a los Servicios

Los servicios:

- Brindan información a quien lo necesite
- Realizan peticiones CRUD (create, read, update, delete)
- Mantienen la data de forma persistente
- Sirven como recurso reutilizable para nuestra aplicación

[Volver al Índice](#%C3%ADndice-del-curso)

## 57. Creando nuestro primer servicio - HeroesService

Creamos el directorio src/app/servicios

Y dentro de él el archivo de servicios, por convención será .service src/app/servicios/heroes.service.ts

Para definir el archivo con los snippets podemos hacer "ng2service", sino pues el código sería:

```

import { Injectable } from '@angular/core';

@Injectable()
export class HeroesService {


    constructor() {
        console.log("Servicio listo para usar!!!");
    }
}
```

Posteriormente le informamos a Angular de que dispone de este servicio en app.module.ts:

```
// Servicios
import { HeroesService } from './servicios/heroes.service';
providers: [
    HeroesService
  ],
```

Ahora para usar nuestro servicio en heroes.components.ts primero lo importamos y después lo llamamos en el constructor para usarlo, posteriormente copiamos el array de objetos de los recursos en un objeto privado "private". Luego creamos un metodo público de acceso a los datos.

```

import { Injectable } from '@angular/core';

@Injectable()
export class HeroesService {

    private heroes:any[] = [
        {
          nombre: "Aquaman",
          bio: "El poder más reconocido de Aquaman es la capacidad telepática para comunicarse con la vida marina, la cual puede convocar a grandes distancias.",
          img: "assets/img/aquaman.png",
          aparicion: "1941-11-01",
          casa:"DC"
        },
        {
          nombre: "Batman",
          bio: "Los rasgos principales de Batman se resumen en «destreza física, habilidades deductivas y obsesión». La mayor parte de las características básicas de los cómics han variado por las diferentes interpretaciones que le han dado al personaje.",
          img: "assets/img/batman.png",
          aparicion: "1939-05-01",
          casa:"DC"
        },
        {
          nombre: "Daredevil",
          bio: "Al haber perdido la vista, los cuatro sentidos restantes de Daredevil fueron aumentados por la radiación a niveles superhumanos, en el accidente que tuvo cuando era niño. A pesar de su ceguera, puede \"ver\" a través de un \"sexto sentido\" que le sirve como un radar similar al de los murciélagos.",
          img: "assets/img/daredevil.png",
          aparicion: "1964-01-01",
          casa: "Marvel"
        },
        {
          nombre: "Hulk",
          bio: "Su principal poder es su capacidad de aumentar su fuerza hasta niveles prácticamente ilimitados a la vez que aumenta su furia. Dependiendo de qué personalidad de Hulk esté al mando en ese momento (el Hulk Banner es el más débil, pero lo compensa con su inteligencia).",
          img: "assets/img/hulk.png",
          aparicion: "1962-05-01",
          casa:"Marvel"
        },
        {
          nombre: "Linterna Verde",
          bio: "Poseedor del anillo de poder que posee la capacidad de crear manifestaciones de luz sólida mediante la utilización del pensamiento. Es alimentado por la Llama Verde (revisada por escritores posteriores como un poder místico llamado Starheart), una llama mágica contenida en dentro de un orbe (el orbe era en realidad un meteorito verde de metal que cayó a la Tierra, el cual encontró un fabricante de lámparas llamado Chang)",
          img: "assets/img/linterna-verde.png",
          aparicion: "1940-06-01",
          casa: "DC"
        },
        {
          nombre: "Spider-Man",
          bio: "Tras ser mordido por una araña radiactiva, obtuvo los siguientes poderes sobrehumanos, una gran fuerza, agilidad, poder trepar por paredes. La fuerza de Spider-Man le permite levantar 10 toneladas o más. Gracias a esta gran fuerza Spider-Man puede realizar saltos íncreibles. Un \"sentido arácnido\", que le permite saber si un peligro se cierne sobre él, antes de que suceda. En ocasiones este puede llevar a Spider-Man al origen del peligro.",
          img: "assets/img/spiderman.png",
          aparicion: "1962-08-01",
          casa: "Marvel"
        },
        {
          nombre: "Wolverine",
          bio: "En el universo ficticio de Marvel, Wolverine posee poderes regenerativos que pueden curar cualquier herida, por mortal que ésta sea, además ese mismo poder hace que sea inmune a cualquier enfermedad existente en la Tierra y algunas extraterrestres . Posee también una fuerza sobrehumana, que si bien no se compara con la de otros superhéroes como Hulk, sí sobrepasa la de cualquier humano.",
          img: "assets/img/wolverine.png",
          aparicion: "1974-11-01",
          casa: "Marvel"
        }
      ];

    constructor() {
        console.log("Servicio listo para usar!!!");
    }

    getHeroes() {
        return this.heroes;
    }
}
```

Posteriormente en el componente de héroes heroes.component.ts inicializamos un array que posteriormente rellenaremos usando el método getHeroes() definido previamente:

```
import { Component, OnInit } from '@angular/core';
import { HeroesService } from '../../servicios/heroes.service';
@Component({
  selector: 'app-heroes',
  templateUrl: './heroes.component.html'
})
export class HeroesComponent implements OnInit {

  heroes:any[] = [];

  constructor( private _heroesService:HeroesService ) { // _heroesService es el alias que tendrá el servicio
    console.log("constructor");
  }

  ngOnInit() {
    this.heroes = this._heroesService.getHeroes();
    console.log( this.heroes);
  }

}
```

Si queremos prevenir que no se incluyesen datos fuera de la estructura del objeto de héroes, podemos crear una interfaz en el servicio, tipo:

```
export interface Heroe {
    nombre: string;
    bio: string;
    img: string;
    aparicion: string;
    casa: string;
};
```
Y entonces podemos declarar el array que contendrá la información como:

```
private heroes:Heroe[] = [
```

Y para poder acceder a todas las clases y métodos del servicio podemos importar la interfaz en heroes.components.ts tal que:

```
import { HeroesService, Heroe } from '../../servicios/heroes.service';

```

Y para ser más específicos aún podemos ahora definir el método que devuelve los héroes de esta manera:

```
getHeroes():Heroe[] {
        return this.heroes;
    }
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 58. Página de Heroes - Diseño con *ngFor

Ya que tenemos el array de Héroes guardado como variable local en el componente, podemos generar dinámicamente las tarjetas con esa información.

También podremos llenar información del html con los atributos de los objetos, si por ejemplo queremos src de imagen dinámico, lo definiremos entre []

Quedando el código HTML así:

```
<div class="card-columns">
    <div class="card" *ngFor="let heroe of heroes">
        <img [src]="heroe.img" class="card-img-top" [alt]="heroe.nombre">
        <div class="card-body">
            <h5 class="card-title">{{ heroe.nombre }}</h5>
            <p class="card-text">{{ heroe.bio }}</p>
            <p class="card-text"><small class="text-muted">{{ heroe.aparicion }}</small></p>
            <button type="button" class="btn btn-outline-primary btn-block">
              Ver más...
          </button>
        </div>
    </div>
</div>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 59. Rutas con parametros - Router

Navegación a otra página:

Creamos un nuevo componente con angular-cli:

```
ng g c components/heroe -is
```
Añadimos las rutas al componente (página), en el path debemos indicar que se va a pasar un parámetro, que será el ID del héroe a buscar (mostrar    )

```
import { HeroeComponent } from './components/heroe/heroe.component';
{ path: 'heroe/:id', component: HeroeComponent},
```

Para tener un id podemos sacarlo a la vez que renderizamos todos los objetos del array heroe, con index = i

```
<div class="card animated fadeIn fast" *ngFor="let heroe of heroes; let i = index">
```

Entonces ya podremos generar la ruta en el botón de enlace, usando routerLink se le pasa un array, dicho array serán las posiciones de la URL y sub-posiciones, le pasamos 'heroe' y el ID

```
<a [routerLink]="['/heroe',i]" class="btn btn-outline-primary">Ver más link...</a>
```

Para hacer el botón con programación usaremos un evento click y lanzaremos una función:

```
<button (click)="verHeroe(i)" type="button" class="btn btn-outline-primary btn-block">Ver más...</button>
```

Y en el componente necesitamos las siguientes importacion para habilitar la navegación:

```
import { Router } from '@angular/router';
```

Posteriormente necesitamos una variable de ese tipo:

```
constructor(   private _heroesService:HeroesService,
                 private router:Router) { // _heroesService es el alias que tendrá el servicio
  }
```

Entonces en la función verHeroe usaremos router y un metodo navigate que usa los mismo parametros para componer la url que en routerLink, con un array:

```
verHeroe( idx:number ){
    this.router.navigate( ['/heroe', idx]);
  } 
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 60. Recibiendo parámetros por URL - ActivatedRoute

Para recibir parámetro por URL vamos al componente que recibirá el parámetro, que es 'heroe', la ficha del héroe hacia la que navegar.

Importamos la libreria ActivatedRoute de @angular/router:

```
import { ActivatedRoute } from '@angular/router';
```

Y en el constructor creamos un escuchador para estar suscrito a los cambios que haya en el intercambio de parámetros:

```
this.activatedRoute.params.subscribe( params =>{ // Está constantemene escuchando cambios en params, como en las rutas se definió que se pasaría el id, eso es lo que recibe
      console.log(params['id']);
    })
```

Al igual que el servicio nos devolvía un array de héroes, ahora necesitamos que nos pueda devolver uno solo, tomando como referencia un ID
Para ello creamos un método que realice esta función:

```
getHeroe( idx: string ) {
      return this.heroes[idx];
    }
```

Entonces en el componente héroe ya podemos importar el servicio (que incluye este método), para posteriormente en el constructor generar una instacia del servicio, pudiendo acceder al método y así usarlo para que la variable local que almacena el héroe esté accesible, llenándola con la funcion que nos devuelve un héroes y pasandole el ID que está siendo escuchando en la URL mediante params de activated route:

```
import { Component } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { HeroesService } from '../../servicios/heroes.service';

@Component({
  selector: 'app-heroe',
  templateUrl: './heroe.component.html'
})
export class HeroeComponent {

  heroe:any = {}; // Variable local para mostrar en el template

  constructor( private activatedRoute: ActivatedRoute,
               private _heroesService: HeroesService) {
    this.activatedRoute.params.subscribe( params =>{ // Está constantemene escuchando cambios en params, como en las rutas se definió que se pasaría el id, eso es lo que recibe
      this.heroe = this._heroesService.getHeroe(params['id']);
    });
   }
}

```

[Volver al Índice](#%C3%ADndice-del-curso)

## 61. Tarea práctica #1 - Componente del héroe

Crear la página de héroe, mi resolución:

```
<h1> {{ heroe.nombre }} <small> {{ heroe.aparicion }} </small></h1>
<hr>

<div class="row">
    <div class="col-md-4">
        <img [src]="heroe.img" class="img-fluid" [alt]="heroe.nombre">
        <br><br>
        <a [routerLink]="['/heroes']" class="btn btn-outline-danger btn-block">Regresar</a>
    </div>
</div>
<div class="col-md-8">

    <h3> {{ heroe.nombre }} </h3>
    <hr>
    <p>
        {{ heroe.bio }}
    </p>
    <div *ngIf="heroe.casa == 'Marvel'">
        <img src="././assets/img/marvel-logo.png" alt="Marvel">
    </div>
    <div *ngIf="heroe.casa == 'DC'">
        <img src="././assets/img/dc-logo.jpg" alt="DC">
    </div>
</div>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 62. Resolución de la tarea práctica #1 - Componente del héroe

Resolución del profesor:

```
Como la mía :D
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 63. Pipes: Transformación visual de la data.

Transforman los datos en el template de forma visual

Breve muestra con pipes predefinidos de Angular que se pueden ver en la documentación de Angular.io

```
<h1 class="animated fadeIn"> {{ heroe.nombre | uppercase}} <small> ({{ heroe.aparicion | date:'y'}}) </small></h1>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 64. Buscador de Héroes

En el input del buscador definimos un alias #buscarTexto y que se dispare un evento cuando se pulse "Enter" que ejecuta una función buscarHeroe():

a buscarHeroe() se le pasará como argumento el contenido del input, que como fue definido con un alias, se recogerá con buscarTexto.value

```
<form class="form-inline my-2 my-lg-0">
            <input class="form-control mr-sm-2" type="search" placeholder="Buscar héroe" aria-label="Search" (keyup.enter)="buscarHeroe(buscarTexto.value)" #buscarTexto>
            <button (click)="buscarHeroe(buscarTexto.value)" class="btn btn-outline-primary my-2 my-sm-0" type="button">Buscar</button>
        </form>
```

Ahora creamos la función en el componente del navbar:

```
```

Antes necesitaremos en el servicio poder controlar búsquedas en el array de héroes:

```
buscarHeroes( termino: string ) {

      let heroesArr:Heroe[] = [];
      termino = termino.toLowerCase();

      for ( let heroe of this.heroes ) {
        let nombre = heroe.nombre.toLowerCase();
        if (nombre.indexOf( termino ) >= 0) {
          heroesArr.push(heroe);
        }
      }

      return heroesArr;
    }
```

Lo que hacemos ahí es básicamente recorrer un array temporal que contiene una copia del array de Héroes y comparar con el término que se pasa como parámetro, si el indexOf es mayor que 0 significa que coincide el inicio de las cadenas de texto, por lo tanto la búsqueda coincide

[Volver al Índice](#%C3%ADndice-del-curso)

## 65. Tarea práctica #2: Crear la pantalla de búsqueda de héroes.

Cuando se busque un héroe usar la variable recibida en el input, crear una ruta a un nuevo componente para que en esa página se muestre el héroe (o héroes) que coincidan con el término de búsqueda recibido por el input

[Volver al Índice](#%C3%ADndice-del-curso)

## 66. Resolución de la tarea 2 - Buscador de Héroes.

Crear un nuevo componente:

>ng g c componentes/buscador

Agregar la nueva ruta en app.routes.ts

```
import { BuscadorComponent } from './components/buscador/buscador.component';

{ path: 'buscar/:termino', component: BuscadorComponent},
```

Vamos al componente del buscador que hemos creado y ahí tenemos que recibir el parámetro que recibimos por el input de la barra de navegación, para ello primero importamos el módulo ActivatedRoute que nos permite pasar parámetros por la url:

```
import { ActivatedRoute } from '@angular/router';
```

Para poder usarlo lo instanciamos en el constructor:

```
constructor( private activatedRoute:ActivatedRoute ) { }
```

A continuación como en las rutas definimos que se va a pasar por url un parámetro llamado "término" en el componente de buscador definimos que esté "escuchando" si se pasa dicho parámetro, para ello lo definimos, por ejemplo, en ngOnInit, así queda listo escuchando:

```
this.activatedRoute.params.subscribe( params => {
      console.log(params['termino']);
    })
```

Lo siguientes es redirigir del navbar al componente buscador, así que en el navbar component importamos el router y lo instanciamos en el constructor

```
import { Router } from '@angular/router';
constructor( private router:Router ) { }
```

Entonces en la funcion para buscar ya podemos hacer que navegue al componente buscador, pasandole el término que definimos en app.routes.ts

```
buscarHeroe( termino: string ) {
    //console.log(termino);
    this.router.navigate( ['/buscar',termino]);
  }
```

Nota importante: para que el navbar funcione pulsando enter (keyup.enter) hay que definir el botón como "submit" no como "button", corregido el código

En el componente buscador, posteriormente, importamos el servicio para poder mostrar héroes del servicio en función del parámetro recibido desde el navbar y lo instanciamos en el constructor

```
import { HeroesService } from '../../servicios/heroes.service';
constructor( private activatedRoute:ActivatedRoute,
               private _heroesService:HeroesService  ) {

  }
```

Posteriormente creamos una variable local llamada heroes que usaremos para generar el resultado de la búsqueda, como array, puesto que pueden ser varios los que coincidan con el termino de búsqueda. En la función que definimos en el ngOnInit que escuchaba el parámetro que pasamos por url ahora usamos la función de buscarheroe que definimos en el servicio para guardar en la variable local creada el resultado de la búsqueda por el término:

```
heroes:any[] = []

this.activatedRoute.params.subscribe( params => {
      this.termino = params['termino'];
      this.heroes = this._heroesService.buscarHeroes( params['termino'] );
      console.log( this.heroes )
    });


```

Ahora definamos el html, que será una versión igual o parecida al heroes.component.html, lo único que guardaremos el término del buscador en una variable para usarla en el frontal

```
termino:string;
this.termino = params['termino'];
```

```
<h1>Buscando: <small>{{ termino }}</small></h1>
<hr>

<div class="card-columns">
    <div class="card animated fadeIn fast" *ngFor="let heroe of heroes; let i = index">
        <img [src]="heroe.img" class="card-img-top" [alt]="heroe.nombre">
        <div class="card-body">
            <h5 class="card-title">{{ heroe.nombre }}</h5>
            <p class="card-text">{{ heroe.bio }}</p>
            <p class="card-text"><small class="text-muted">{{ heroe.aparicion }}</small></p>
            <button (click)="verHeroe(i)" type="button" class="btn btn-outline-primary btn-block">Ver más...</button>
            <!-- <a [routerLink]="['/heroe',i]" class="btn btn-outline-primary">Ver más link...</a> -->
        </div>
    </div>
</div>
```
[Volver al Índice](#%C3%ADndice-del-curso)

## 67. Plus: Mostrando un mensaje cuando no hay resultados.

Simplemente definimos que se muestre o no el mensaje en función de si el array tiene valores o no

```
<div class="row animated fadeIn fast" *ngIf="heroes.length == 0">
    <div class="col-md-12 col-lg-12">
        <div class="alert alert-info" role="alert">
            No existen resultados con el término: {{ termino }}
        </div>
    </div>
</div>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 68. @Input - Recibir información de un componente padre a un hijo.

Vamos a extraer el código html del componente de héroes que define la tarjeta del héroe, para definir un componente independiente de tarjeta, lo cual usaremos para practicar la tranfusión de información de elementos padres a hijos y viceversa.

Empezamos por generar un componente con el Angular CLI:

> ng g c components/heroeTarjeta

Una vez generado vamos a modificar heroes.component.html, sacaremos el ngFor del html de la tarjeta y lo comentaremos, para tener constancia de que así se generaba antes, dinámicamente en función de los datos que se recibían del servicio, posteriormente sacaremos el html de la tarjeta de ahí y lo pondremos en el html del nuevo componente heroe-tarjeta.component.html

Quedando heroes.component.html:

```
<h1>Héroes <small>Marvel y DC</small></h1>
<hr>
<!-- *ngFor="let heroe of heroes; let i = index" -->
<div class="card-columns">

</div>
```

Y heroe-tarjeta.component.html:

```
<div class="card animated fadeIn fast">
    <img [src]="heroe.img" class="card-img-top" [alt]="heroe.nombre">
    <div class="card-body">
        <h5 class="card-title">{{ heroe.nombre }}</h5>
        <p class="card-text">{{ heroe.bio }}</p>
        <p class="card-text"><small class="text-muted">{{ heroe.aparicion }}</small></p>
        <button (click)="verHeroe(i)" type="button" class="btn btn-outline-primary btn-block">Ver más...</button>
        <!-- <a [routerLink]="['/heroe',i]" class="btn btn-outline-primary">Ver más link...</a> -->
    </div>
</div>
```

Ahora en heroe-tarjeta.component.ts necesitaremos el héroe, por lo cual lo definimos en la clase del componente como un objeto de tipo "any" vacío:

```
export class HeroeTarjetaComponent implements OnInit {

  heroe: any = {};
```

Y en la plantilla html de heroes.component.html ahora podemos llamar al componente por el selector y usar el ngFor que dejamos comentado anteriormente, quedando el código de esta manera:

```
<h1>Héroes <small>Marvel y DC</small></h1>
<hr>
<!-- *ngFor="let heroe of heroes; let i = index" -->
<div class="card-columns">
    <app-heroe-tarjeta *ngFor="let heroe of heroes; let i = index"></app-heroe-tarjeta>
</div>
```

Para pasar la información del componente padre (heroes.component) al componente hijo (heroe-tarjeta.component) necesitamos importar "Input" en el componente hijo de la librería de angular/core. Esto le dirá a Angular que una propiedad va a ser recibida desde afuera.

> import { Component, OnInit, Input } from '@angular/core';

Usando el decorador en la clase indicamos que puede venir desde afuera, pero si no fuera así podemos usar la propiedad desde el constructor normalmente, por ejemplo con algún parámetro por defecto, etcétera.

> @Input() heroe: any = {};

Entonces desde la llamada al componente, en el selector, podemos pasarle una propiedad al hijo, como el ngFor recibe el servicio y genera un array de datos, podemos pasarle ese "heroe" de esta manera:

```
    <app-heroe-tarjeta [heroe]="heroe" *ngFor="let heroe of heroes; let i = index"></app-heroe-tarjeta>
```

A continuación vamos a definir la función verHeroe que al haber movido el html ya no se encuentra definida en el nuevo archivo de typescript. El índice lo vamos a definir como nueva propiedad del Input. Para hacer la redirección en la función de primeras lo vamos a hacer como hicimos en el hereos.component usando Router. Esto también lo actualizaremos en el html del buscador. El código que resulta es el siguiente.

```
import { Component, OnInit, Input } from '@angular/core';
import { Router } from '@angular/router';

@Component({
  selector: 'app-heroe-tarjeta',
  templateUrl: './heroe-tarjeta.component.html'
})
export class HeroeTarjetaComponent implements OnInit {

  @Input() heroe: any = {};
  @Input() index: number;

  constructor( private router:Router ) { }

  ngOnInit(): void {
  }
  verHeroe() {
    this.router.navigate( ['/heroe', this.index]);
  }
}
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 69. @Output - Emitir un evento del hijo hacia el padre.

Aquí haremos lo contrario que en la lección anterior. Que el hijo emita un evento, mientras que el padre está escuchando, y cuando lo escuche realice una acción.

Para ello en este caso práctico vamos a utilizar la función verHeroe que teníamos en heroes.component.ts, queremos llamar a esa función del padre desde el hijo (heroe-tarjeta.component)

Primeramente en el componente hijo importamos "Output" de angular/core, que va de la mano con EventEmitter que se encargará de emitir el evento que el componente padre tiene que escuchar.

Al igual que definimos las propiedades con los decoradores @Input vamos a declarar la propiedad para @Output, pero en este caso tendrá el nombre del evento que queremos que escuche el padre. Además tendremos que especificar que es de tipo EventEmitter, y también que tipo de dato es el que se emitirá, como lo que queremos es el índice del array de héroe, que es de tipo number, quedará:

> @Output() heroeSeleccionado: EventEmitter<number>

En el constructor necesito inicializar el EventEmitter

```
constructor( private router:Router ) { 
    this.heroeSeleccionado = new EventEmitter();
  }
```

Ahora podemos usar el objeto en la función verHeroe para, usando el método propio "emit", emitir el índice que nos interesa, quedando:

```
verHeroe() {
    // this.router.navigate( ['/heroe', this.index]);
    this.heroeSeleccionado.emit( this.index );
  }
```

Ahora el padre debe tener la posibilidad de escuchar, para cuando se emita el índice pueda escucharlo, para ello nos vamos al componente padre, al selector del componente hijo, en lugar de usar un evento tipo click, por ejemplo, usaremos nuestro evento propio definido como heroeSeleccionado, el cual ejecutará la función verHeroe, y como esta necesita un indice, lo que le vamos a pasar es el índice que emite nuestro evento. El código sería el siguiente:

```
import { Component, OnInit, Input, Output, EventEmitter } from '@angular/core';
import { Router } from '@angular/router';

@Component({
  selector: 'app-heroe-tarjeta',
  templateUrl: './heroe-tarjeta.component.html'
})
export class HeroeTarjetaComponent implements OnInit {

  @Input() heroe: any = {};
  @Input() index: number;

  @Output() heroeSeleccionado: EventEmitter<number>

  constructor( private router:Router ) { 
    this.heroeSeleccionado = new EventEmitter();
  }

  ngOnInit(): void {
  }
  verHeroe() {
    // this.router.navigate( ['/heroe', this.index]);
    this.heroeSeleccionado.emit( this.index );
  }
}

```

[Volver al Índice](#%C3%ADndice-del-curso)

## 70. Arreglar detalles de la búsqueda.

Vamos a implementar el que, tras hacer una búsqueda y que aparezca la ficha de un héroe, se pueda hacer click en "Ver más" y funcione :)

Para ello vamos a alterar de nuevo la función verHeroe, en lugar de que funcione con el evento, lo dejaremos como estaba antes, usando Router.

El problema está en el servicio, porque los objetos no tienen un ID único. Como lo que usamos el la posición del array (el index), cuando realizamos una búsqueda satisfactoria, nos devuelve un array, al tratar de abrir esa ficha de héroe usa el índice, entonces nos devuelve la posición del objeto de héroes del servicio ... para arreglar esto vamos a arreglar la búsqueda.

Vamos a modificar el bucle for que nos rellenaba el arreglo de heroes de la búsqueda, ahora recorreremos todo el array y guardaremos la posición, la cual será opcional y será definida como tal al final, así añadiremos al array de héroes ese dato adicional, el código actualizado quedará así:

```

import { Injectable } from '@angular/core';

@Injectable()
export class HeroesService {

    private heroes:Heroe[] = [
        {
          nombre: "Aquaman",
          bio: "El poder más reconocido de Aquaman es la capacidad telepática para comunicarse con la vida marina, la cual puede convocar a grandes distancias.",
          img: "assets/img/aquaman.png",
          aparicion: "1941-11-01",
          casa:"DC"
        },
        {
          nombre: "Batman",
          bio: "Los rasgos principales de Batman se resumen en «destreza física, habilidades deductivas y obsesión». La mayor parte de las características básicas de los cómics han variado por las diferentes interpretaciones que le han dado al personaje.",
          img: "assets/img/batman.png",
          aparicion: "1939-05-01",
          casa:"DC"
        },
        {
          nombre: "Daredevil",
          bio: "Al haber perdido la vista, los cuatro sentidos restantes de Daredevil fueron aumentados por la radiación a niveles superhumanos, en el accidente que tuvo cuando era niño. A pesar de su ceguera, puede \"ver\" a través de un \"sexto sentido\" que le sirve como un radar similar al de los murciélagos.",
          img: "assets/img/daredevil.png",
          aparicion: "1964-01-01",
          casa: "Marvel"
        },
        {
          nombre: "Hulk",
          bio: "Su principal poder es su capacidad de aumentar su fuerza hasta niveles prácticamente ilimitados a la vez que aumenta su furia. Dependiendo de qué personalidad de Hulk esté al mando en ese momento (el Hulk Banner es el más débil, pero lo compensa con su inteligencia).",
          img: "assets/img/hulk.png",
          aparicion: "1962-05-01",
          casa:"Marvel"
        },
        {
          nombre: "Linterna Verde",
          bio: "Poseedor del anillo de poder que posee la capacidad de crear manifestaciones de luz sólida mediante la utilización del pensamiento. Es alimentado por la Llama Verde (revisada por escritores posteriores como un poder místico llamado Starheart), una llama mágica contenida en dentro de un orbe (el orbe era en realidad un meteorito verde de metal que cayó a la Tierra, el cual encontró un fabricante de lámparas llamado Chang)",
          img: "assets/img/linterna-verde.png",
          aparicion: "1940-06-01",
          casa: "DC"
        },
        {
          nombre: "Spider-Man",
          bio: "Tras ser mordido por una araña radiactiva, obtuvo los siguientes poderes sobrehumanos, una gran fuerza, agilidad, poder trepar por paredes. La fuerza de Spider-Man le permite levantar 10 toneladas o más. Gracias a esta gran fuerza Spider-Man puede realizar saltos íncreibles. Un \"sentido arácnido\", que le permite saber si un peligro se cierne sobre él, antes de que suceda. En ocasiones este puede llevar a Spider-Man al origen del peligro.",
          img: "assets/img/spiderman.png",
          aparicion: "1962-08-01",
          casa: "Marvel"
        },
        {
          nombre: "Wolverine",
          bio: "En el universo ficticio de Marvel, Wolverine posee poderes regenerativos que pueden curar cualquier herida, por mortal que ésta sea, además ese mismo poder hace que sea inmune a cualquier enfermedad existente en la Tierra y algunas extraterrestres . Posee también una fuerza sobrehumana, que si bien no se compara con la de otros superhéroes como Hulk, sí sobrepasa la de cualquier humano.",
          img: "assets/img/wolverine.png",
          aparicion: "1974-11-01",
          casa: "Marvel"
        }
      ];

    constructor() {
        console.log("Servicio listo para usar!!!");
    }

    getHeroes():Heroe[] {
      return this.heroes;
    }

    getHeroe( idx: string ) {
      return this.heroes[idx];
    }

    buscarHeroes( termino: string ) {
      let heroesArr:Heroe[] = [];
      termino = termino.toLowerCase();

      for ( let i = 0; i < this.heroes.length; i++) {
        
        let heroe = this.heroes[i];

        let nombre = heroe.nombre.toLowerCase();

        if ( nombre.indexOf( termino ) >= 0 ) {
          heroe.idx = i;
          heroesArr.push( heroe );
        }
      }
      return heroesArr;
    }
}
export interface Heroe {
    nombre: string;
    bio: string;
    img: string;
    aparicion: string;
    casa: string;
    idx?: number;
};

```

Ya que tenemos el índice correcto tendremos que llamarlo en el buscador.component.html, quedando:

```
<app-heroe-tarjeta [heroe]="heroe" [index]="heroe.idx" *ngFor="let heroe of heroes"></app-heroe-tarjeta>

```

[Volver al Índice](#%C3%ADndice-del-curso)

# Sección 5: Pipes - Transforman los valores mostrados en pantalla

## 72. Introducción a la sección

Básicamente un pipe es un método o una función, que recibe una serie de argumentos (como mínimo uno), los cuales los procesará y devolverá un dato que necesitemos.

Esta salida no muta el objeto que estemos manipulando, el cambio será sólo visual (por ejemplo un pipe para pasar un string a mayúsculas no alteraría esa variable)

[Volver al Índice](#%C3%ADndice-del-curso)

## 73. ¿Qué aprenderemos en esta sección?

A continuación vamos a entrar a profundidad sobre el tema de los PIPES, que no es más que una transformación visual de la data.

En detalle veremos:

Pipes uppercase y lowercase

Pipe Slice

Pice Decimal

Pipe Percent

Pipe Currency

Pipe Json

Pipe Async

Pipe Date

Pipes personalizados

Capitalizar palabras y nombres

Creación de un pipe, que permite cargar recursos externos de forma segura.

Al final de la sección tendremos una tarea para afianzar los conocimientos creando un pipe personalizado que nos permitirá ocultar un texto a voluntad.

[Volver al Índice](#%C3%ADndice-del-curso)

## 74. Demostración del resultado de la sección - Pipes

Ver vídeo explicativo con el resultado de la sección.

[Volver al Índice](#%C3%ADndice-del-curso)
## 75. Inicio del proyecto y la introducción a los Pipes

- Se llaman así porque usan el caracter pipe "|" para poder trabajar con ellos en el HTML, también se pueden utilizar del lado de los componentes.

- Únicamente funcionan para transformar los datos de manera visual, no cambian el valor, no mutan los objetos si son pasados por referencia

- Ejemplos:
  - texto = "hola mundo" -> {{ texto | uppercase }} -> HOLA MUNDO (El valor de la variable 'texto' seguiría estando en minúscula)
  - fecha = new Date(1985,10,21) -> {{ fecha | date:"dd/MM/yy" }} -> 21/11/1985

Generamos el nuevo proyecto de la sección:

> ng new pipes

Cuando pregunte si queremos generar las rutas le indicamos que no, y para estilos lo dejaremos en CSS

Una vez generado renombraremos el directorio a 03-pipes para coherencia con el resto del curso

A continuación levantamos el proyecto con:

> ng serve -o

Vamos a eliminar todo el contenido de app.component.html para generar nosotros ahí nuestro código, posteriormente instalaremos bootstrap.

Getbootstrap.com -> get started -> copiar link de estilos y añadirlo al index.html

```
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
```

Añadiremos al body la class container <body class="container">

El código que dejaremos definido para trabajar en el app.component.html será:

```
<h1 class="mt-3">Pipes <small>Angular</small></h1>
<hr>

<div class="row">
    <div class="col">
        <table class="table">
            <thead class="thead-dark">
                <tr>
                    <th> Variable </th>
                    <th> Pipe </th>
                    <th> Salida </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </tbody>
        </table>
    </div>
</div>
```

En app.component.ts vamos a definir una variable tipo string para empezar a trabajar con ella:

```
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  
  nombre: string = 'Capitán América';
  
}
```
Entonces podremos llamarla en el html, usando los primeros pipes que vamos a aprender "uppercase" y "lowercase" los cuales vienen definidos por defecto con Angular y no hay que importar nada ni hacer nada adicional para usarlo:

```
<h1 class="mt-3">Pipes <small>Angular</small></h1>
<hr>

<div class="row">
    <div class="col">
        <table class="table">
            <thead class="thead-dark">
                <tr>
                    <th> Variable </th>
                    <th> Pipe </th>
                    <th> Salida </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td> {{ nombre }} </td>
                    <td> uppercase </td>
                    <td> {{ nombre | uppercase }} </td>
                </tr>
                <tr>
                    <td> {{ nombre }} </td>
                    <td> lowercase </td>
                    <td> {{ nombre | lowercase }} </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>
```



[Volver al Índice](#%C3%ADndice-del-curso)
## 76. Pipe: Slice

Para recortar cadenas o arrays, requiere al menos un parámetro, en estos dos ejemplos, cuando definimos como parámetro ":3" estamos indicando que corte a partir del tercer carácter de la cadena, si definimos como parámetro ":0:3" estamos diciendo que empiece la cadena en la posición 0 y acabe en la posición 3:

```
 <tr>
                    <td> {{ nombre }} </td>
                    <td> slice:3 </td>
                    <td> {{ nombre | slice:3 }} </td>
                </tr>
                <tr>
                    <td> {{ nombre }} </td>
                    <td> slice:0:3 </td>
                    <td> {{ nombre | slice:0:3 }} </td>
                </tr>
```

Para probar con un array vamos a declarar uno en el archivo ts:

> array: [1,2,3,4,5,6,7,8,9,10];

Podemos incluso usar el pipe en un bucle para formatear el resultado, independientemente de si hay suficientes valores para cortar o no:

```
<tr>
  <td> {{ array }} </td>
  <td> slice:1:5 </td>
  <td> {{ array | slice:1:5 }} </td>
</tr>
<h4> Slice </h4>
<ul>
    <li *ngFor="let item of array | slice:5:20"> {{ item }} </li>
</ul>
```

[Volver al Índice](#%C3%ADndice-del-curso)
## 77. Pipe: Decimal

Ver documentación en angular.io sobre DecimalPipe

Creamos una variable numérica con decimales en app.component.ts:

> PI:     number = Math.PI;

El formateo visual del número decimal o entero se realiza pasando un argumento string que define el formato deseado, como ejemplos:

```
<tr>
    <td> {{ PI }} </td>
    <td> number:'3.0-0' </td>
    <td> {{ PI | number:'3.0-0' }} </td>
</tr>
<tr>
    <td> {{ PI }} </td>
    <td> number:'.0-2' </td>
    <td> {{ PI | number:'.0-2' }} </td>
</tr>
```

[Volver al Índice](#%C3%ADndice-del-curso)
## 78. Pipe: Percent - Porcentajes

Al igual que en la lección anterior, este pipe recibe un string como argumento, revisar angular.io en la documentación para más info.

En app.component.ts creamos otra variable de ejemplo:

> porcentaje: number = 0.234;

Y en app.component.html:

```
<tr>
    <td> {{ porcentaje }} </td>
    <td> percent </td>
    <td> {{ porcentaje | percent }} </td>
</tr>
<tr>
    <td> {{ porcentaje }} </td>
    <td> percent:'2.2-2' </td>
    <td> {{ porcentaje | percent:'2.2-2' }} </td>
</tr>
```

[Volver al Índice](#%C3%ADndice-del-curso)
## 79. Pipe: Currency - Moneda

Al igual que en lecciones anteriores, revisar angular.io para la documentación, para el ejemplo creamos una variable en app.component.ts:

> salario:    number = 1234.5;

En este caso para formatear podemos usar el argumento currencyCode para usar un código de país y así usar su divisa. Ejemplificado en el html quedaría:

```
<tr>
    <td> {{ salario }} </td>
    <td> currency:'EUR' </td>
    <td> {{ salario | currency:'EUR' }} </td>
</tr>
<tr>
    <td> {{ salario }} </td>
    <td> currency:'CAD':'symbol-narrow':'.0-0' </td>
    <td> {{ salario | currency:'CAD':'symbol-narrow':'.0-0' }} </td>
</tr>
```

[Volver al Índice](#%C3%ADndice-del-curso)
## 80. Pipe: Json

Como en casos anteriorer, revisar documentación de angular.io JsonPipe. Para practicar nosotros creamos en app.component.ts un nuevo objeto:

```
heroe = {

    nombre: 'Logan',
    clave: 'Wolverine',
    edad: 500,
    dirección: {
      calle: 'Primera',
      casa: 20
    }
  }
```

Si intentáramos llamar directamente a {{ heroe }} en nuestro html nos aparecería [object Object]. Porque estaría tratando de representar un objeto como un string, texto plano, en el HTML, para eso sirve este pipe, para formatear la información y mostrarla como un objeto JSON. Para ejemplificarlo en nuestro app.component.html:

```
<h4> JSON </h4>
  <hr>
  <div class="row mb-5">
      <div class="col">
          {{ heroe | json }}
      </div>
  </div>
```

[Volver al Índice](#%C3%ADndice-del-curso)
## 81. Pipe: Async

Revisamos en angular.io la información sobre el pipe AsyncPipe. Vamos a crear una promesa en app.component.ts para ejemplificar:

```
valorPromesa = new Promise<string>( (resolve) => {

    setTimeout(()=> {
      resolve('llego la data');
    }, 4500);

});
```

Similar al caso del pipe de JSON, si tratamos de imprimir directamente en el html 'valorPromesa' nos mostrará [object Promise], al pasarlo por el pipe "async" nos mostrará el string que resuelve la promesa, en el html quedaría:

```
<tr>
    <td> {{ valorPromesa }} </td>
    <td> Async </td>
    <td> {{ valorPromesa | async }} </td>
</tr>
```


[Volver al Índice](#%C3%ADndice-del-curso)
## 82. Pipe: Date - Fecha

Revisamos en angular.io la documentación del pipe DatePipe que gestiona fechas.

Para nuestra práctica creamos una fecha en app.component.ts:

> fecha:      Date = new Date();

En cuanto al "idioma" de la fecha podemos usar el argumento 'timezone' para configuararlo, nosotros vamos a hacer una configuración propia del 'locale', instalándolo globalmente para que el navegador lo detecte y esa variable tome valor en función del idioma del navegador o dónde se está ejecutando este, para ello usando el angular CLI lo instalamos de la siguiente manera:

> ng add @angular/localize

Esto nos prepara y actualiza el archivo src/polyfills.ts , a continuación tendremos que realizar una configuración, para eso tenemos que añadir en src/app/app.module.ts lo siguiente:

```
import { registerLocaleData } from '@angular/common';
import  localEs  from '../../node_modules/@angular/common/locales/es';
registerLocaleData(localEs);
```

Nótese que 'localEs' será lo que usemos para registrar/llamar al idioma en la funcion registerLocaleData(localEs);

Para terminar de configurar manualmente esto deberemos añadir en app.module.ts: 

```
import { NgModule, LOCALE_ID } from '@angular/core';// LOCALE_ID nos provee de un token de localización

providers: [
    {
      provide: LOCALE_ID,
      useValue: 'es'
    }
  ],
```

Esto también cambiará la visualización de algunas cosas, por ejemplo la posición del símbolo de moneda, que en España se pone al final, en lugar de al principio.

Finalmente el código de ejemplo que usaremos en el html será el que sigue:

```
<tr>
  <td> {{ fecha }} </td>
  <td> date </td>
  <td> {{ fecha | date }} </td>
</tr>
<tr>
  <td> {{ fecha }} </td>
  <td> date:'medium' </td>
  <td> {{ fecha | date:'medium' }} </td>
</tr>
<tr>
  <td> {{ fecha }} </td>
  <td> date:'short' </td>
  <td> {{ fecha | date:'short' }} </td>
</tr>
<tr>
  <td> {{ fecha }} </td>
  <td> date:'MMMM - dd' </td>
  <td> {{ fecha | date:'MMMM - dd' }} </td>
</tr>
```

[Volver al Índice](#%C3%ADndice-del-curso)
## 83. Registrar otros idiomas

Vamos a configurar el registro de tres idiomas para testear esta posibilidad.

En la lección anterior cuando hicimos esta instalación:

> ng add @angular/localize

Lo que hicimos fue instalar localmente todos los idiomas en nuestra máquina, pero no están en la aplicación. Hasta que no hacemos el registro usando la función registerLocaleData no formarán parte del bundle de la app.

Vamos a registrar algunos idiomas adicionales al español, actualizando el archivo app.module.ts:

```
import  localEs  from '../../node_modules/@angular/common/locales/es';
import  localFr  from '../../node_modules/@angular/common/locales/fr';

registerLocaleData(localEs);
registerLocaleData(localFr);
```

En el html podremos usar el pipe para que lo muestre en francés de la siguiente manera:

```
<tr>
  <td> {{ fecha }} </td>
  <td> date:'MMMM - dd':'':'fr' </td>
  <td> {{ fecha | date:'MMMM - dd':'':'fr' }} </td>
</tr>
```

Como ejercicio adicional vamos a crear una variable en el componente que registre un string, ese string lo vamos a usar como valor del locale como argumento para el pipe:

```
idioma:     string = 'es';
```

De esta manera podemos maquetar el html para que cuando se haga click en unos botones cambie el valor de dicho string y, por tanto, del argumento del locale, haciendo que el filtro del pipe cambie y pudiendo así cambiar el idioma de la fecha:

```
<tr>
                    <td> {{ fecha }} </td>
                    <td> date:'MMMM - dd':'':'{{ idioma }}'
                        <br>
                        <button (click)="idioma='en'" class="mr-1 btn btn-secondary">Inglés</button>
                        <button (click)="idioma='es'" class="mr-1 btn btn-primary">Español</button>
                        <button (click)="idioma='fr'" class="mr-1 btn btn-success">Francés</button>
                    </td>
                    <td> {{ fecha | date:'MMMM - dd':'':idioma }} </td>
                </tr>
```
[Volver al Índice](#%C3%ADndice-del-curso)
## 84. Pipes personalizados: Capitalizar palabras

Vamos a crear unos pipes personalizados, para empezar vamos a declarar una nueva variable en nuestro app.component.ts, para ver el efecto definiremos el string con caracteres en mayúsculas y minúsculas alternados:

```
nombre2:     string = 'eDuarDo CórDOba jOAquíN';
```

Posteriormente, para crear nuestro pipe, podemos hacerlo directamente con el angular CLI de esta manera, por convención se genera un directorio "pipes":

> ng g p pipes/capitalizado

Esto nos crea el directorio, el archivo spec de testeo y el archivo ts de definición del pipe, asimismo nos actualiza el app.module.ts de esta manera:

```
import { CapitalizadoPipe } from './pipes/capitalizado.pipe';

@NgModule({
  declarations: [
    AppComponent,
    CapitalizadoPipe
  ],
```

Al haber sido añadido a "declarations" toda la aplicación sabrá de la existencia del pipe creado

A continuación tenemos el código del archivo ts del pipe, vamos a describirlo posteriormente

```
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'capitalizado'
})
export class CapitalizadoPipe implements PipeTransform {

  transform(value: unknown, ...args: unknown[]): unknown {
    return null;
  }

}
```

Es como cualquier otra clase, solo que tenemos el decorador @Pipe, en el cual tenemos el nombre definido de nuestro pipe 'capitalizado', el que usaremos cuando queramos aplicar el formateo.

Posteriormente tenemos la función PipeTransform que será la que se encargue de realizar la transformación en el html

'value' será el valor del string (o el valor que queramos transformar, en otros casos) y 'args' serán todos los argumentos que se envíen a la función, en :unknown al final de la función definiremos el tipo de valor de salida de la función (lo que devolverá el return dentro de la función, por defecto está 'null')

Vamos a realizar una primera modificación de la función para ver su efecto, como tipo de valor devuelto vamos a especificar que va a ser de tipo string, y el retorno de la función va a ser el string 'Hola Mundo'

```
transform(value: unknown, ...args: unknown[]): string {
    return 'Hola Mundo';
  }
```

Si ahora en nuestro html aplicamos el pipe personalizado 'capitalizado' en el html lo que aparecerá en lugar del contenido de la variable 'nombre2' será 'Hola Mundo', recordemos que el valor de la variable 'nombre2' sigue existiendo, pero el resultado visual sería el que hemos indicado.

```
<tr>
    <td> {{ nombre2 }} </td>
    <td> capitalizado </td>
    <td> {{ nombre2 | capitalizado }} </td>
</tr>
```

Vamos a definir dentro de la función del pipe un par de console log para comprender cómo funciona. Si hacemos un console.log(value) veremos en la consola del navegador que, efectivamente, el valor de la variable nombre2 sigue siendo el que era, como hemos comentado anteriormente.

```
transform(value: unknown, ...args: unknown[]): string {
    console.log(value);
    console.log(args);
    return 'Hola Mundo';
  }
```

El console.log(args) en principio nos mostrará por consola un array vacío, pero probemos a definir argumentos de prueba para ver la salida,por ejemplo un número, un booleano y un string:

```
<tr>
    <td> {{ nombre2 }} </td>
    <td> capitalizado </td>
    <td> {{ nombre2 | capitalizado:1:true:'Hola' }} </td>
</tr>
```

De tal manera podemos ver los argumentos en consola, o capturarlos, la salida por consola del console.log(args) una vez definidos esos argumentos sería:

>[1, true, "Hola"]

Por tanto podríamos usar la desestructuración de array en la función, o podríamos simplemente definir los argumentos de la función que queramos, por ejemplo inventemos un 'edad', 'activo' y 'mensaje', para que concuerden con los valores que hemos especificado en el ejemplo anterior, y vamos a hacer la prueba de imprimirlos por consola de nuevo:

```
transform(value: unknown, edad: number, activo: boolean, mensaje: string): string {
    console.log(value);
    console.log({ edad, activo, mensaje });
    return 'Hola Mundo';
  }
```

La salida por consola queda tal que:

```
{edad: 1, activo: true, mensaje: "Hola"}
activo: true
edad: 1
mensaje: "Hola"
```

Una vez comprendido esto vamos a dejar definido de manera más útil para nosotros la función de la siguiente manera, definiremos un argumento 'todas' booleano, para controlar la capitalización de los caracteres. Definiremos el value como string para controlar que lo que se recibe en la función, el valor a modificar, es un string, lo cual también nos permitirá acceder a los métodos y funciones tipo string para trabajar. Entonces en la función recibiremos un string, este string lo pasaremos a minúscula por completo, luego cortaremos ese string y lo almacenaremos en un array de nombres, considerando un espacio en blanco como patrón de corte. Si en este punto hacemos un console.log(nombres) veremos imprime por consola ["eduardo", "córdoba", "joaquín"]. Efectivamente pasó todo a minúscula y las palabras por separado, ahora sólo necesitaríamos capitalizar el primer caracter de cada string del array y volver a unir todo el array en un solo string. Para esto primero preguntaremos, teniendo en cuenta el argumento booleano 'todas', si queremos capitalizar todas las palabras, cuando sea 'false' sólo se capitalizaría la primera palabra. Explicamos la función con comentarios dentro de la misma.

```
transform(value: string, todas: boolean = true): string {
    
    value = value.toLocaleLowerCase(); // Pasamos todo el string a minúscula

    let nombres = value.split(' '); // definimos un array y en él guardamos las palabras que componen el string, usando los espacios en blanco como separador

    if ( todas ) { // Si todas == true
      nombres = nombres.map( nombre => { // Usamos la función map para definir una función por cada uno de los elementos del array 'nombres'
        return nombre[0].toUpperCase() + nombre.substr(1); // Pasamos el primer caracter(posicion) de cada uno de los elementos del array (nombres[0]) a mayúscula, y le concatenamos el resto del array desde la posición 1 (subtr(1))
      });
    } else { // Si todas == false solamente al primer elemento del array le pasamos a mayúscula su primer caracter(posición) (nombres[0][0]) y concatenamos el resto desde la posición 1 (nombres[0].substr(1))
      nombres[0] = nombres[0][0].toUpperCase() + nombres[0].substr(1);
    }

    return nombres.join(' '); // Devolvemos como string el array usando como unión un espacio en blanco

  }
```

Y dejaremos el html preparado también, pasandole el argumento "true", aunque en la función ya habíamos definido que por defecto valdría "true"

```
<tr>
    <td> {{ nombre2 }} </td>
    <td> capitalizado </td>
    <td> {{ nombre2 | capitalizado:true }} </td>
</tr>
```

[Volver al Índice](#%C3%ADndice-del-curso)
## 85. Pipe Personalizado: Domseguro

En esta clase vamos a intentar colocar un vídeo o enlace externo en nuestra aplicación de Angular, y vamos a ver qué sucede.

Para ello por ejemplo vamos a YouTube y copiamos el iframe de un video a nuestra elección y lo incluímos en nuestro html:

```
<h4 class="mt-4"> Domseguro </h4>
<hr>
<div class="row mb-5">
    <div class="col">
        <iframe width="560" height="315" src="https://www.youtube.com/embed/Brl7WmHDG-E" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
        </iframe>
    </div>
</div>
```

A continuación en nuestro app.component.ts definimos una variable que contenga el string del enlace del vídeo:

```
videoUrl:   string = 'https://www.youtube.com/embed/Brl7WmHDG-E';
```

De nuevo en nuestro html tratamos de cargar el atributo de src del enlace usando la variable de Angular:

```
<div class="row mb-5">
            <div class="col">
                <iframe width="560" height="315" [src]="videoUrl" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
                </iframe>
            </div>
        </div>
```

Entonces no cargará el vídeo, y si miramos la consola nos da un aviso de que se está tratando de cargar un recurso que es potencialmente inseguro:

> ERROR Error: unsafe value used in a resource URL context

Esto es porque el string de la variable podría ser un script o algo que Angular considera que hay que bloquear por seguridad. Pero si nosotros confiamos en el recurso que queremos cargar entonces tendremos que realizar un pequeño trabajo.

Para poder cargar recursos que vengan de fuera de nuestra aplicación, cuando nos esté dando esa indicación de unsafe value (puede suceder también con el CSS, algunas url, etc), vamos a crear un pipe domseguro.

> ng g p pipes/domseguro

Una vez creado el pipe, vamos a trabajar en la función, dicha función recibirá un string, y lo que haremos en nuestra función será pasarle un sanitizer a ese string, que nos permita limpiar o validar dicho string. En las librerías de Angular disponemos de dicho recurso, el cual vamos a importar en nuestro domseguro.pipe.ts:

```
import { DomSanitizer } from '@angular/platform-browser'
```

Tenemos que hacer la inyección del método en nuestra clase, para ello lo declaramos en el constructor, que definimos previamente.

Lo que devolverá la función con el return será una llamada a uno de los métodos de Domsanitizer dependiendo de lo que requiramos en cada caso, en este en concreto necesitamos 'bypassSecurityTrustResourceUrl', su nombre se explica por sí mismo :) lo que recibe ese método es el value, que será el string a sanear.

Si vemos el tooltip del método, vemos que retorna un tipo 'SafeResourceUrl', el cual dejaremos definido también en nuestra función del pipe. A priori no lo encontrará, así que lo definiremos también en el import anterior, puesto que se encuentra en el mismo paquete de Angular.

Finalmente el código de nuestro pipe quedará de esta manera:

```
import { Pipe, PipeTransform } from '@angular/core';
import { DomSanitizer, SafeResourceUrl } from '@angular/platform-browser'
@Pipe({
  name: 'domseguro'
})
export class DomseguroPipe implements PipeTransform {

  constructor( private domSanitizer: DomSanitizer  ) {}

  transform(value: string, ...args: unknown[]): SafeResourceUrl {
    return this.domSanitizer.bypassSecurityTrustResourceUrl( value );
  }

}
```

Ahora ya podemos usar nuestro pipe y carga correctamente, porque aplica el pipe antes de que se termine de renderizar todo el html.

```
<div class="row mb-5">
            <div class="col">
                <iframe width="560" height="315" [src]="videoUrl | domseguro" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
                </iframe>
            </div>
        </div>
```


[Volver al Índice](#%C3%ADndice-del-curso)
## 86. Tarea de Pipes

La tarea consiste en crear un pipe que, dada una variable que contiene un string, a través de un evento click en un botón oculte o muestre la llamada en el html de dicha variable string, sustituyéndola por asteriscos o mostrando su formato original. Hasta donde llegué fue:

Crear un pipe con el Angular cli

> ng g p pipes/contrasena

Me atasqué en la creación de la función que altera visualmente el string, no sabiendo bien qué opción elegir para checkear la cadena de caracteres y cómo sustituirla por los valores de asterisco, tenía en mente pasar la variable de string a array de string y recorrerla, etc, lo dejé hasta donde llegué porque intuía que la solución seguramente sería más sencilla. A continuación los códigos fuente del componente y del html creado para la tarea:

```
import { ValueConverter } from '@angular/compiler/src/render3/view/template';
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'contrasena'
})
export class ContrasenaPipe implements PipeTransform {
  transform(value: string, activar:boolean ): string[] {
    let cadena = value;
    if ( activar ) {
      let contrasena = []
      for (let i = 0; i < cadena.length; i++) {
        contrasena[i]= '*'
        console.log(contrasena)     
      }   
return contrasena
    } else {
      //return value;
    }    
  }
}
```

```
<tr>
  <td> {{ nombre }} </td>
  <td> contrasena:{{ activar }}
      <br>
      <button (click)="activar = !activar" class="btn btn-outline-primary">Activar/Desactivar</button>
  </td>
  <td> {{ nombre | contrasena:activar }} </td>
</tr>
```
[Volver al Índice](#%C3%ADndice-del-curso)
## 87. Resolución de la tarea de Pipes

Primero creamos el pipe mediante el CLI

> ng g p pipes/contrasena

Efectivamente el profesor resuelve la parte de la función de manera mucho más sencilla, usando métodos actualizados de ECMAScript (.repeat()), con un condicional ternario.

```
 transform(value: string, mostrar:boolean = false ): string {
    return ( mostrar ) ? '*'.repeat( value.length ) : value;
  }
```

De esta manera comprueba si mostrar es verdadero, en tal caso devuelve un string que será consecuencia del carácter * devuelto tantas veces como sea la longitud del string original, en caso de que sea falso simplemente devolverá el string original (value)

El resto de la lógica la tenía correcta, ¡a por la siguiente sección!

[Volver al Índice](#%C3%ADndice-del-curso)

# Sección 6:Aplicación #3: SpotiApp
## 89. Introducción a la sección

En esta sección aprenderemos a desarrollar un aplicación que consume recursos de la API de Spotify, así como conceptos de HTTP, haciendo peticiones GET al servidor de Spotify, usando su API. Vamos a poder obtener su música, artistas, crearnos una pantalla de interfaz, crear un slideshow. También podremos usar el widget de Spotify para poder reproducir la canción completa. Por último veremos una introducción a la transformación de los datos que viene del servicio API de Spotify, pasándolo por un método map, para de esa manera poder usar esa información como nosotros queramos, también almacenaremos información en los servicios para que la información persista a pesar de movernos de página, al usar las rutas.

[Volver al Índice](#%C3%ADndice-del-curso)

## 90. ¿Qué aprenderemos en esta sección?

Vamos a crear una aplicación que nos ayudará a comprender sobre los siguientes temas:

1. Reforzamiento de rutas y parámetros de rutas.
2. Uso de carruseles del Bootstrap 4
3. Uso del HTTP para obtener información
4. Uso de la API de Spotify para obtener información de:
- a. Artistas
- b. Albumes
- c. Audio
5. Trabajo sobre el manejo de data asíncrona.
6. ngModel para enlazar campos de texto a variables del componente.
7. Widgets de Spotify
8. HTML5 audio
9. Observables
10. Maps
Durante la sección tendremos tareas y al final un examen teórico para reforzar los conocimientos adquiridos.

[Volver al Índice](#%C3%ADndice-del-curso)

## 91. Demostración del resultado de esta sección

Ver vídeo mostrando el resultado de la aplicación terminada y sus funcionalidades y conceptos aprendidos en ella.

[Volver al Índice](#%C3%ADndice-del-curso)

## 92. Sitio web de developer de Spotify

Sitio web de developer de Spotify

Actualización del sitio de Developer de Spotify

En esta sección crearemos una aplicación que consume los servicios de Spotify.

Pueden ver lo servicios en esta dirección

https://beta.developer.spotify.com/console/

Tengan esa página a mano, la necesitaremos pronto

[Volver al Índice](#%C3%ADndice-del-curso)

## 93. Iniciando el proyecto - SpotiApp

Primeramente descargamos una serie de recursos para la sección, unas imágenes y un archivo de estilos CSS.

Crearemos en nuevo proyecto yendo a la raíz del curso y usando el Angular cli:

> ng new spotiapp

Mientras vamos a https://developer.spotify.com/console/ porque aquí necesitamos hacer dos cosas: Crear en Spotify una aplicación y ver cómo funciona en la api de Spotify.

Vamos a https://developer.spotify.com/dashboard/ y hacemos login. (Yo por suerte tengo cuenta premium)

Posteriormente le damos a "CREATE A CLIENT ID"

Una vez creado ya dispondremos de dos datos fundamentales que son el CLIENT ID y el CLIENT ID SECRET. Ambas van a ser necesarias para crear un token.

Ya debió de terminar la creación de la app, la renombramos a 04-spotiapp

Levantamos la aplicación con `ng serve` en nuestra línea de comandos previa navegación al directorio de la nueva aplicación.

A continuación vamos a crear un par de componentes que vamos a necesitar para la aplicación, una página "home" `ng g c components/home --skipTests -is`, una página de "search" `ng g c components/search --skipTests -is`, una página de artista `ng g c components/artista --skipTests -is` y por último otro componente que estará en un subdirectorio compartido para el navbar `ng g c components/shared/navbar --skipTests -is` (--skipTests no genera archivos de test unitarios, -is es inline style, no genera referencias a archivos CSS externos y tampoco lo refiere dentro del archivo ts del componente). Crearemos más componentes a lo largo de la aplicación, pero de momento para empezar necesitaremos esos.

Copiaremos en el directorio /src/assets/ el directorio img que habíamos descargado anteriormente del archivo comprimido de recursos de la sección.

Del mismo origen copiaremos el archivo styles.css y lo sustituiremos por el que ya se encuentra en src/styles.css

Por último iremos a la página de getbootstrap.com / Descargas y añadir el CDN a nuestro index.html, dejando el <link> en el <head> y el <script> al final del <body>. También copiaremos los <script> del jquery y del popper colocándolos justo antes del <script> del bootstrap.

```
<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Spotiapp</title>
    <base href="/">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
</head>

<body>
    <app-root></app-root>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js" integrity="sha384-q2kxQ16AaE6UbzuKqyBE9/u/KzioAlnx2maXQHiDX9d4/zp8Ok3f+M7DPm+Ib6IU" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.min.js" integrity="sha384-pQQkAEnwaBkjpqZ8RU1fF1AKtTcHJwFl3pblpTlHXybJjHpMYo79HY3hIi4NKxyj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW" crossorigin="anonymous"></script>
</body>

</html>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 94. Creando las rutas de nuestra aplicación

Vamos a crear un archivo nuevo en src/app/app.routes.ts

```
import { Routes } from '@angular/router';
import { HomeComponent } from './components/home/home.component';
import { SearchComponent } from './components/search/search.component';



export const ROUTES: Routes = [
    { path: 'home', component: HomeComponent },
    { path: 'search', component: SearchComponent },
    { path: '', pathMatch: 'full', redirectTo: 'home'}, // Cualquier otro path no definido nos redireccionará al home
    { path: '**', pathMatch: 'full', redirectTo: 'home'} // Cualquier otro path no definido nos redireccionará al home
];
```

En app.module.ts es donde pondremos el módulo de rutas.

Aquí en app.module.ts importaremos el módulo de rutas y lo incluiremos en los imports, asegurarnos en el imports que está cogiendo la constante del app.routes, y además definiremos que usaremos el HASH para las url (#), quedando el archivo tal que:

```
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router'

import { AppComponent } from './app.component';
import { HomeComponent } from './components/home/home.component';
import { SearchComponent } from './components/search/search.component';
import { ArtistaComponent } from './components/artista/artista.component';
import { NavbarComponent } from './components/shared/navbar/navbar.component';
import { ROUTES } from './app.routes';

// Importación de rutas

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    SearchComponent,
    ArtistaComponent,
    NavbarComponent
  ],
  imports: [
    BrowserModule,
    RouterModule.forRoot( ROUTES, { useHash: true } ) // Quiero usar el hash
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

Posteriormente vaciamos el app.component.html precargado de Angular. Incluiremos el componente de navbar, un div container y el router-outlet para posibilitar la navegación entre componentes. Para el navbar vamos a coger código de bootstrap que incluiremos en el navbar.component.html.

```
<nav class="navbar navbar-expand-md navbar-dark bg-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="#">
            <img src="/assets/img/banner-ico.png" alt="" width="30" height="30"> Spotiapp
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item" routerLinkActive="active">
                    <a class="nav-link" aria-current="page" routerLink="home">Home</a>
                </li>
                <li class="nav-item" routerLinkActive="active">
                    <a class="nav-link" routerLink="search">Search</a>
                </li>
            </ul>
        </div>
    </div>
</nav>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 95. Introducción a las peticiones HTTP

Aquí obtendremos recursos mediante peticiones HTTP o Ajax, para ello necesitaremos un sitio al que pedir dicha información, para practicar vamos a ir al sitio web http://restcountries.eu/ y buscamos una lista de países por el lenguaje (API ENDPOINTS - Language).

Podemos testear con la aplicación externa Postman para hacer un get a la url: https://restcountries.eu/rest/v2/lang/es de tal manera que nos devuelve un objeto en formato JSON con la información de países que hablan español.

Para poder trabajar con este tipo de solicitudes en nuestra aplicación de Angular necesitamos dos cosas:

1. Importar en app.module.ts algo que nos permita hacer peticiones HTTP (`import { HttpClientModule } from '@angular/common/http';`), en HttpClientModule se incluyen una serie de herramientas que vamos a necesitar en nuestra app, entre ellas la que me permite hacer peticiones HTTP. Lo incluímos en los imports (ya que se trata de un módulo).

```
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { HttpClientModule } from '@angular/common/http';

import { AppComponent } from './app.component';
import { HomeComponent } from './components/home/home.component';
import { SearchComponent } from './components/search/search.component';
import { ArtistaComponent } from './components/artista/artista.component';
import { NavbarComponent } from './components/shared/navbar/navbar.component';
import { ROUTES } from './app.routes';

// Importación de rutas

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    SearchComponent,
    ArtistaComponent,
    NavbarComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule,
    RouterModule.forRoot( ROUTES, { useHash: true } ) // Quiero usar el hash
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

```

2. En nuestro home.component.ts vamos a incluir el código para manejar la información, en nuestro constructor declaramos `private Http: HttpClient`. De esta manera al cargar la app y, por tanto, este componente, tendré a disposicion los métodos de http, entre ellos el que nos permite hacer las peticiones.

```
constructor( private http: HttpClient ) {
    console.log('Constructor del home cargado');
    this.http.get('https://restcountries.eu/rest/v2/lang/es');
  }
```

De esta manera tenemos la información hecha, pero necesitamos suscribirnos/escuchar esta petición para poder manejar los datos que devuelve. Para ello al metodo get le añadimos a continuación un submétodo 'subscribe' en el cual definiremos mediante una función de flecha una variable en la cual guardaremos la información devuelta por el get.

```
constructor( private http: HttpClient ) {
    console.log('Constructor del home cargado');
    this.http.get('https://restcountries.eu/rest/v2/lang/es')
      .subscribe( respuesta => {
        console.log(respuesta);
      })
  }
```

Una vez que estamos suscritos a esa información podemos llamarla, vamos a definir una variable países y en el constructor guardaremos la respuesta en dicha variable.

```
import { HttpClient } from '@angular/common/http';
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html'
})
export class HomeComponent implements OnInit {

  paises: any[] = [];

  constructor( private http: HttpClient ) {
    console.log('Constructor del home cargado');
    this.http.get('https://restcountries.eu/rest/v2/lang/es')
      .subscribe( (respuesta:any) => {
        this.paises = respuesta;
        console.log(respuesta);
      })
  }

  ngOnInit(): void {
  }

}
```

Ahora ya podemos acceder a la información en el html:

```
<ul>
    <li *ngFor="let pais of paises">
        {{ pais.name }} - {{ pais.population | number }}
    </li>
</ul>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 96. Actualización - Token para uso de servicios Spotify

Para trabajar con la información o los servicios de Spotify nosotros utilizamos un token que ellos nos van a generar. Tendremos que hacer una petición para obtener un token.

Nos vamos a https://developer.spotify.com/documentation/. Hay varias formas de trabajar con la API de Spotify, vía web API y otras maneras, nosotros para este caso usaremos WEB API, hacemos click ahí y nos vamos a Guides -> Autorization Guide y bajamos hasta Client Credentials Flow.

Como vemos ahí el flow es sencillo, solicitamos un token proporcionando nuestros CLIENT ID y CLIENT ID SECRET, nos devuelve el token y en la solicitud a la api proporcionamos dicho token, devolviéndonos la información en formato JSON.

Para obtener el token haremos una petición `POST https://accounts.spotify.com/api/token` añadiendo en el Body->x-www-form-urlencoded la key 'grant_type' y en VALUE 'client_credentials', además necesitamos darle las keys 'client_id' y 'client_secret' con los VALUE que disponemos en nuestra cuenta de developer de Spotify. Nos devolverá información con el 'access_token' que expira cada hora 'expires_in:3600'.

Guardaremos esto en el Postman para tener la referencia.

[Volver al Índice](#%C3%ADndice-del-curso)

## 97. HTTPClient - Service: Conectándonos a Spotify

Vamos a trabajar con nuestra primera interacción con Spotify. Nos dirijimos a https://developer.spotify.com/console/ -> Browse

Para practicar vamos a usar la petición GET que nos da los nuevos lanzamientos de Spotify `GET	/v1/browse/new-releases` porque es lo que vamos a mostrar en el home. Si hacemos click en el enlace de esa petición nos lleva a una página donde podemos hacer pruebas. Ahí podemos definir algunas variables para definir la respuesta que queremos, como el país, la cantidad de datos que queremos que devuelva y a partir de cual registro queremos que devuelva valores (country,limit,offset). en OAuth Token podemos tocar para generar el token que utilizaríamos para dicha petición, usará nuestra cuenta de Spotify para genera el token. Si hacemos click en Try It veremos el JSON que genera. Pero todo esto es sólo para testearlo y verlo.

Vamos a testearlo ahora en Postman, copiamos el endpoint `https://api.spotify.com/v1/browse/new-releases` y creamos una nueva solicitud GET en el Postman incluyendo este endpoint, en los Headers tenemos que incluir la key 'Autorization' y en value 'Bearer BQA8T9W7bdw266ilzogCBlseFNIB5yMEpZ4IQTPbRBRH51QsV2RLGwbiyaRQi6gj8X2ZdFUJ4u9A8JI6kZU' siendo la cadena larga el token que nos generamos anteriormente en la lección anterior (podemos regenerarlo si no sirve puesto que tiene una duración de 1 hora). Lo ejecutamos y nos devuelve el JSON con la información.

Para tener esto del lado de Angular, puesto que es una información de una API externa lo ideal es centralizar la información, y para centralizar la información es recomendable crear un servicio, vamos a crearlo con angular CLI:

> ng g s services/spotify --skipTests

Anterior a la versión de Angular nos creaba también la información en el app.module.ts ahora, sin embargo, ahora en el spotify.service.ts nos encontramos:

```
@Injectable({
  providedIn: 'root'
})
```

Esto indica a la aplicación, al cargar el servicio, que debe ser incluído en los providers y hace que no sea necesario incluirlo en los providers dentro del app.module.ts

Vamos a hacer una petición a la api de Spotify, en nuestro spotify.service.ts crearemos una función para hacer una petición http a un endpoint y que quede guardado en una variable para luego poder trabajar con ello:

```
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class SpotifyService {

  constructor( private http: HttpClient) {
    console.log('Spotify Service Listo');
   }
   getNewReleases() {
    this.http.get('https://api.spotify.com/v1/browse/new-releases')
      .subscribe( data => {
        console.log(data);
      });
   }
}
```

Si ahora queremos hacer uso de ello por ejemplo en nuestro componente de la home de esta manera nos acabará dando un error de no token provided:

```
import { Component, OnInit } from '@angular/core';
import { SpotifyService } from '../../services/spotify.service';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html'
})
export class HomeComponent {

  constructor( private spotify: SpotifyService) {
    this.spotify.getNewReleases();
  }

  ngOnInit(): void {
  }

}
```

Entonces lo que necesito es modificar los headers de la petición, regresando a spotify.service.ts en el HttpClient del import incluímos HttpHeaders que nos permitirá esas modificaciones. Con ello podremos crear una constante tipo HttpHeader que nos dejará añadir información en formato de objeto con la información que necesitemos incluir en los headers, en nuestro caso la autorización:

```
const headers = new HttpHeaders({
      'Authorization': 'Bearer BQA8T9W7bdw266ilzogCBlseFNIB5yMEpZ4IQTPbRBRH51QsV2RLGwbiyaRQi6gj8X2ZdFUJ4u9A8JI6kZU'
    });
```

Además tendremos que decirle a nuestra función get que se van a usar esos headers, de tal manera que todo el código de la función quedaría así (vamos a añadir el límite en 20, aunque la verdad es que ya estaba definido así a través del token):

```
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class SpotifyService {

  constructor( private http: HttpClient) {
    console.log('Spotify Service Listo');
   }
   getNewReleases() {

    const headers = new HttpHeaders({
      'Authorization': 'Bearer BQA8T9W7bdw266ilzogCBlseFNIB5yMEpZ4IQTPbRBRH51QsV2RLGwbiyaRQi6gj8X2ZdFUJ4u9A8JI6kZU'
    });
    this.http.get('https://api.spotify.com/v1/browse/new-releases?limit=20', { headers })
      .subscribe( data => {
        console.log(data);
      });
   }
}

```

[Volver al Índice](#%C3%ADndice-del-curso)

## 98. Consumiendo información del servicio de Spotify

Si al cargar nuestra aplicación nos diera un error de token tendremos que volver a Postman y hacer una solicitud POST de token de nuevo, y en nuestro spotify.service.ts actualizar el token en el headers.

Vamos a usar unas tarjetas de bootstrap para trabajar con la información que tenemos de la función getNewReleases() que actualmente sólo la tenemos en consola.

Tomaremos información de los álbumes y la mostraremos en tarjetas.

Vamos a modificar de nuevo la función getNewReleases, eliminando el subscribe y que sólo nos devuelva toda la información mediante un return:

```
getNewReleases() {

    const headers = new HttpHeaders({
      'Authorization': 'Bearer BQCI4NYAn9ET-5cv61XCybtwihkcnwvPQDafccRAWCW9VpjvRQpxIIl1_rSKkQmQEKJzBvkWUk8MEkDXOeQ'
    });

    return this.http.get('https://api.spotify.com/v1/browse/new-releases?limit=20', { headers });
    
   }
```

De esta manera, donde yo llame a la función getNewReleases() puedo añadirle el .suscribe, por ejemplo en el home.component.ts, esto nos permitiría, por ejemplo, introducir un "loading" para manejar tiempos de carga en el constructor del componente de home. Declararemos una variable nuevasCanciones para almacenar los items de los albumes que nos devuelve la solicitud http

```
export class HomeComponent {

  nuevasCanciones: any[] = [];

  constructor( private spotify: SpotifyService) {
    this.spotify.getNewReleases()
    .subscribe( (data: any) => {
      this.nuevasCanciones = data.albums.items;
    });
  }

  ngOnInit(): void {
  }

}
```

Ahora podremos montar nuestro html de la home con bootstrap (cards + badges) y rellenando la información deseada:

```
<div class="row">
    <div *ngFor="let cancion of nuevasCanciones" class="card col-3">
        <img class="card-img-top" [src]="cancion.images[0].url">
        <div class="card-body">
            <h5 class="card-title">{{ cancion.name }}</h5>
            <p class="card-text">
                <span *ngFor="let artista of cancion.artists" class="badge rounded-pill bg-primary">{{ artista.name }}</span>
            </p>
        </div>
    </div>
</div>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 99. Componente de Búsqueda de artistas

Ahora trabajaremos en la sección "search", la idea es crear un buscador para filtrar la búsqueda de los nuevos lanzamientos que recibimos en nuestra app.

Empezamos con el html, introduciremos un input donde haremos la búsqueda, en este input estará la función que nos permitirá "buscar()" y un #termino de referencia que será lo que usemos para buscar los artistas, así que lo que la función hará será "buscar(termino.value)", al definir #termino estamos creando la posibilidad de referenciar al valor que se encuentre en el input. Esto se enviará cada vez que se suelte una tecla pulsada, debido al evento (keyup). Quedando el html y el ts, respectivamente, de esta manera:

```
<div class="row">
    <div class="col">
        <input #termino type="text" (keyup)="buscar(termino.value)" class="form-control" placeholder="Buscar artista..." name="" id="">
    </div>
</div>
```

```
import { Component } from '@angular/core';

@Component({
  selector: 'app-search',
  templateUrl: './search.component.html',
  styles: []
})
export class SearchComponent {

  constructor() { }

  buscar(termino: string) {
    console.log(termino);
  };

}
```

A continuación trabajaremos en el servicio para poder gestionar la búsqueda, para ello vamos a https://developer.spotify.com/console/ y en "search" hacemos click en el endpoint que nos ofrece `https://api.spotify.com/v1/search`, para la generación de token las variables que nos ofrece son q* (el término a buscar, por ejemplo Metallica), type* (si es una canción o artista), market (el país del mercado, de esto pasaremos), límit (límite de 15, pondremos), si damos a "try it" y da error tendremos que generar el token de nuevo en esa misma página.

Regresamos a nuestro servicio de spotify spotify.service.ts y tendremos que crear un nuevo servicio getArtista(), para este servicio necesitaré el término de búsqueda. El código será prácticamente igual al que ya teníamos de getNewReleases(), cambiará el return, puesto que la url de petición get es distinta, cogeremos la url del ejemplo que teníamos en la consola de Spotify Developers, y como esa url recibe un término usaremos la variable para generar la url deseada. El string de la url la delimitaremos por backticks para poder concatenar la variable. Es decir, originalmente la cadena es: `https://api.spotify.com/v1/search?q=ed%20sheeran&type=artist&limit=15` y en lugar de eso quedaría de esta manera:

```
getArtista( termino: string ) {

    const headers = new HttpHeaders({
      'Authorization': 'Bearer BQDt7vsa4s73U0L4PpmZEHm-PwckR1TWg4AP30YMDoMNB3ijj714erHbSt6mVXZaDjvLj_OBKCPqft3fgno'
    });

    return this.http.get(`https://api.spotify.com/v1/search?q=${ termino }&type=artist&limit=15`, { headers });

   }  
```

Regresamos al search.component.ts puesto que para usar el servicio necesito inyectarlo en el constructor, nos aseguramos de que lo importe de nuestro servicio spotify.service.ts y así ya podemos usarlo en nuestra función buscar, con sus métodos get, etc. Entonces al llamar al servicio getArtists recibiendo el término, ya podemos suscribirnos a los datos que devuelven para manipularlos en nuestro html. 

Reutilizaremos el html de la home y lo adaptaremos a lo que queremos en el search, más adelante optimizaremos todo el código porque estamoos reutilizando mucho. El html necesita ser pulido en temas de estilo, así como controlar que no reciba imágenes rotas, pero se arreglará más adelante, queda tal que así, de momento:

```
<div class="row">
    <div class="col">
        <input #termino type="text" (keyup)="buscar(termino.value)" class="form-control" placeholder="Buscar artista..." name="" id="">
    </div>
</div>

<div class="row">
    <div *ngFor="let artista of artistas" class="card col-3 m-2">
        <img class="card-img-top" [src]="artista.images[0].url">
        <div class="card-body">
            <h5 class="card-title">{{ artista.name }}</h5>
        </div>
    </div>
</div>
```

Y el código del search.component.ts tal que así:

```
import { Component } from '@angular/core';
import { SpotifyService } from 'src/app/services/spotify.service';

@Component({
  selector: 'app-search',
  templateUrl: './search.component.html',
  styles: []
})
export class SearchComponent {

  artistas: any[] = [];

  constructor(private spotify: SpotifyService) { }

  buscar(termino: string) {
    console.log(termino);
    this.spotify.getArtista( termino )
      .subscribe( (data: any) => {
        console.log(data);
        this.artistas = data.artists.items;
      });
  };

}

```

[Volver al Índice](#%C3%ADndice-del-curso)

## 100. Operador Map de los Observables

En esta lección haremos todas las optimizaciones pendientes. Vamos a comenzar con el operador map. ¿Para qué sirve?

Vamos a trabajarlo en el home.component.ts. En este componente cuando llamamos a la función del servicio getNewReleases nos suscribimos a una "data" que es el resultado de la petición http GET, esto es un JSON con una gran cantidad de información por lo general. El operador map se adjuntará a nuestra petición u observable (http.get) lo va a filtrar y nos va a devolver únicamente lo que a nosotros nos sirva. Es decir, toma toda la información pero la cambia, la adapta a lo que sólo necesitamos, pero en esencia sigue estando toda la información ahí.

Para implementarlo en nuestra app vamos a usarlo en nuestro home.component.ts, actualmente a la función le especificamos que queremos data.albums.items, deberíamos poder pedir simplemente la data y que nos la de ya filtrada de antemano, y como esto se define en el servicio vamos a spotify.service.ts para definir el operador map allí.

Primeramente hay que importar el operador map, esto no está en las librerías de Angular, sino de Reactive Extensions (RxJS), que son unas librerías de JavaScript para manipular observables y funciones asíncronas. Nosotros necesitamos el "map" que se encuentra en la sección "operators" de rxjs `import { map } from 'rxjs/operators';`.

En nuestro observable ahora podemos añadirle una función pipe que nos sirve para filtrar, y esta función recibe como argumento la función map para definir el filtrado deseado, este map recibirá la información en bruto que nos devuelve el método get previo en la "data", la cual es consecuencia de una función de flecha en la cual especificaremos el return que deseamos, en este caso queríamos solo los items que pertenecen a la propiedad albums de todo el JSON que devuelve el GET (data), resumiendo el código quedaría tal que así:

```
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { map } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class SpotifyService {

  constructor( private http: HttpClient) {
    console.log('Spotify Service Listo');
   }
   getNewReleases() {

    const headers = new HttpHeaders({
      'Authorization': 'Bearer BQDt7vsa4s73U0L4PpmZEHm-PwckR1TWg4AP30YMDoMNB3ijj714erHbSt6mVXZaDjvLj_OBKCPqft3fgno'
    });

    return this.http.get('https://api.spotify.com/v1/browse/new-releases?limit=20', { headers })
      .pipe( map( data => {
        return data['albums'].items;
      }));
   }
```

Podemos abreviar un poco más las funciones, porque cuando las funciones de flecha tienen una sóla línea, y esa línea es un return (como es nuestro caso) se pueden definir así:

```
getNewReleases() {

    const headers = new HttpHeaders({
      'Authorization': 'Bearer BQBMAjYA59yQOox2qI3E2t0BrXjObYO-00kpZNAqbRGIzBidws586Kuzpwt8kCDsusoyj82q5jU-1pcavhw'
    });

    return this.http.get('https://api.spotify.com/v1/browse/new-releases?limit=20', { headers })
      .pipe( map( data => data['albums'].items ) );
   }
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 101. Centralizar las peticiones hacia Spotify

Ahora optimizaremos el código duplicado, puesto que en el spotify.service.ts tenemos funciones prácticamente idénticas.

Para empezar tenemos una "query" o condición que se distingue de un lugar a otro, pero el resto de la url es la misma (hablando de las peticiones GET). Vamos a centralizar esto, para ello vamos a realizar una función que llamaremos getQuery(), la cual recibirá el query di tipo string, que será el código exclusivamente único para las funciones getNewReleases() y getArtista(). Crearemos una constante "url" que tendrá como objetivo centralizar la petición, es decir, si cambiara la versión de v1 a v2 solo tendríamos que cambiar esa constante y se actualizaría en el resto de cadenas.

Esa constante además se completará con una variable, que será la query particular de cada función. Buscamos unificar y centralizar.

Ahora mediante variables podríamos tener la función definida así:

```
getQuery( query: string ) {

    const url = `https://api.spotify.com/v1/${ query }`;

    const headers = new HttpHeaders({
      'Authorization': 'Bearer BQBMAjYA59yQOox2qI3E2t0BrXjObYO-00kpZNAqbRGIzBidws586Kuzpwt8kCDsusoyj82q5jU-1pcavhw'
    });

    return this.http.get(url, { headers });

  }
```

Llegados a este punto es mucho más claro simplemente leer el código ya terminado, todo centralizado y unificado, el archivo spotify.service.ts queda:

```
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { map } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class SpotifyService {

  constructor( private http: HttpClient) {
    console.log('Spotify Service Listo');
   }
   
  getQuery( query: string ) {

    const url = `https://api.spotify.com/v1/${ query }`;

    const headers = new HttpHeaders({
      'Authorization': 'Bearer BQBMAjYA59yQOox2qI3E2t0BrXjObYO-00kpZNAqbRGIzBidws586Kuzpwt8kCDsusoyj82q5jU-1pcavhw'
    });

    return this.http.get(url, { headers });

  }

  getNewReleases() {

    return this.getQuery('browse/new-releases?limit=20')
      .pipe( map( data => data['albums'].items ) );
  }

  getArtista( termino: string ) {

    return this.getQuery(`search?q=${ termino }&type=artist&limit=15`)
      .pipe( map( data => data['artists'].items ) );    
  }

}
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 102. Verificación de imagen y pipe para manejar las imágenes

Toca optimizar las imágenes ahora, en nuestro componente search tenemos un problema, cuando hacemos una búsqueda de artista y ese artista no tienen una imagen asociada o bien no sale, o sale rota, tenemos error en consola de que no puede encontrarlo, etc.

Podemos resolver esto de muchas maneras, con alguna función, con un operador map que verifique los datos, etc. Nosotros en este caso vamos a usar un pipe.

Vamos a crearlo con el angular CLI

> ng g p pipes/noimage --skipTests

Vamos a search.component.html la idea es que `[src]="artista.images[0].url"` sea validado antes de ser mostrado. Vamos a configurar nuestro noimage.pipe.ts.

El value que recibirá será el array de imágenes, no tendrá argumentos adicionales y devolverá un string (la url de la imagen). Haremos varias validaciones, la primera sería si el value que recibe no es válido, es decir, recibe un null, undefined o algo similar, lo que devuelva sea una imagen por defecto, en el material adjunto de la sección hay un noimage.png que usaremos para esto. La copiaremos a src/ap/assets/img/noimage.png. Nótese que la ruta relativa se considera que empieza desde el index.html, por eso para localizar la imagen por defecto que queremos devolver empezamos desde "assets".

Si por contrario si viniera una imagen, es decir la longitud de esa variable es mayor de 0, devolveremos la url de la posición 0 del array de imágenes. Pero si no fuera así también devolveríamos la imagen por defecto.

Para usarlo, como lo que devuelve en caso correcto es `images[0].url` tendremos que eliminarlo del html y generarlo aplicándole el pipe, de tal manera que el código html quedaría con `[src]="artista.images | noimage"`. El código tanto del pipe como del html quedarían como a continuación:

```
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'noimage'
})
export class NoimagePipe implements PipeTransform {

  transform( images: any[] ): string {
    
    if ( !images ) {
      return 'assets/img/noimage.png'; // Se considera que los path relativos empiezan en el index.html
    }
    if ( images ) {
      return images[0].url;
    } else {
      return 'assets/img/noimage.png';
    }
  }

}
```

```
<div class="row">
    <div class="col">
        <input #termino type="text" (keyup)="buscar(termino.value)" class="form-control" placeholder="Buscar artista..." name="" id="">
    </div>
</div>

<div class="row">
    <div *ngFor="let artista of artistas" class="card col-3 m-2">
        <img class="card-img-top" [src]="artista.images | noimage">
        <div class="card-body">
            <h5 class="card-title">{{ artista.name }}</h5>
        </div>
    </div>
</div>
```

NOTA IMPORTANTE: Parece ser que de esta manera no terminaba de funcionar, otro alumno encontró una solución, dejo el código del noimage.pipe.ts modificado:

```
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'noimage'
})
export class NoimagePipe implements PipeTransform {

  transform( images: any[] ): string {
    return images.length === 0 ? 'assets/img/noimage.png' : images[0].url;
  }
}
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 103. Componente de tarjetas

Seguimos optimizando código, en este caso tenemos duplicado el html del home y del search, son códigos prácticamente iguales.

Así que vamos a centralizar el código, creándonos un nuevo componente:

> ng g c components/tarjetas --skipTests

Copiaremos todo el código de home.component.html y lo copiaremos en tarjetas.component.html. Entonces en home.component.html ya podemos llamar a `<app-tarjetas></app-tarjetas>`. Como anteriormente home trabajaba con las nuevasCanciones definidas en su ts, ahora deberemos pasarle esos valores a app-tarjetas `<app-tarjetas [items]="nuevasCanciones"></app-tarjetas>`

En tarjetas.component.ts tendremos que recibir esa información con un @input que deberemos importar desde @Angular/core, que hemos llamado "items", por tanto tendremos que cambiar html y adaptar de cancion como variable a items.

Lo mismo para el componente search, solo que lo que le pasaremos como valor de "items" será artista en lugar de nuevasCanciones. Quedarían así entonces los archivos:

tarjetas.component.ts

```
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-tarjetas',
  templateUrl: './tarjetas.component.html',
  styleUrls: ['./tarjetas.component.css']
})
export class TarjetasComponent {

  @Input() items: any[] = [];

  constructor() { }

}

```

tarjetas.component.html

```
<div class="row m-5">
    <div *ngFor="let item of items" class="card col-3">
        <img class="card-img-top" [src]="item.images | noimage">
        <div class="card-body">
            <h5 class="card-title">{{ item.name }}</h5>
            <p class="card-text">
                <span *ngFor="let artista of item.artists" class="badge rounded-pill bg-primary">{{ artista.name }}</span>
            </p>
        </div>
    </div>
</div>
```

home.component.html

```
<app-tarjetas [items]="nuevasCanciones"></app-tarjetas>
```

search.component.html

```
<div class="row">
    <div class="col">
        <input #termino type="text" (keyup)="buscar(termino.value)" class="form-control" placeholder="Buscar artista..." name="" id="">
    </div>
</div>

<app-tarjetas [items]="artistas"></app-tarjetas>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 104. Creando un loading component

En esta lección vamos a crear un loading que diga al usuario que espere por favor mientras la data viene de nuestros servicios. Esto será un nuevo componente que vamos a crear como de uso general, y que incluiremos en el directorio shared, por tanto.

> ng g c components/shared/loading --skipTests

Ahora podemos llamar a `<app-loading></app-loading>` en home.component.html, por ejemplo, al principio de todo antes del resto del código.

Para generarl algo visualmente bonito en el html del nuevo componente loading vamos a utilizar fontawesome.com, nos vamos al sitio web y lo instalamos mediante el CDN a través de "Get Started". (Nota: ha cambiado un poco,hay que registarse y el link es tipo <script>).

Incluímos el código en el index.html.

A continuación crearemos el html del loading.component.html:

```
<div class="row text-center animated fadeIn">
    <div class="col">
        <i class="fas fa-sync fa-spin fa-5x"></i>
    </div>
</div>
```

La idea de este loading es que sólo aparezca cuando estamos cargando información, y cuando ya tengamos la información debería desaparecer.

Esto lo vamos a controlar con un *ngIf, asi que para ello nos vamos al home.component.ts y creamos una nueva propiedad loading: boolean; la inicializaremos en el constructor como true y en la función que cargar los lanzamientos al final la definiremos como false (es decir, cuando ya haya realizado la funcion, lo que significaría que ya se cargaron todos los datos), quedaría así:

```
export class HomeComponent {

  nuevasCanciones: any[] = [];
  loading: boolean;

  constructor( private spotify: SpotifyService) {

    this.loading = true;

    this.spotify.getNewReleases()
    .subscribe( (data: any) => {
      this.nuevasCanciones = data;
      this.loading = false;
    });
  }

  ngOnInit(): void {
  }

}
```

Ahora puedo regresar al home.component.html e implementar la condicional:

```
<app-loading *ngIf="loading"></app-loading>
<app-tarjetas [items]="nuevasCanciones"></app-tarjetas>
```

Haremos lo mismo para el search.

[Volver al Índice](#%C3%ADndice-del-curso)

## 105. Página del artista, nueva ruta, parámetro por url y servicio

En esta lección definiremos que en la página de search, cuando hagamos click en alguno de los artistas que busquemos nos lleve a la página del artista.

En el setup inicial del proyecto ya habíamos dejado creado el componente "artista".

Necesitamos el ID del artista para cuando vayamos a hacer click, porque en https://developer.spotify.com/console/artists/ el parámetro que requiere el endpoint es el ID. Este ID ya lo tenemos porque forma parte de uno de los atributos que componen el objeto de artista que recibimos con el GET en la petición http.

Para comenzar necesitamos definir una nueva ruta y que esta controle el parámetro del ID que se pasa por la url.

En app.routes.ts añadimos la nueva ruta indicando que recibirá el id como parámetro:

```
export const ROUTES: Routes = [
    { path: 'home', component: HomeComponent },
    { path: 'search', component: SearchComponent },
    { path: 'artist/:id', component: ArtistaComponent },
    { path: '', pathMatch: 'full', redirectTo: 'home'}, // Cualquier otro path no definido nos redireccionará al home
    { path: '**', pathMatch: 'full', redirectTo: 'home'} // Cualquier otro path no definido nos redireccionará al home
];
```

Ahora en tarjetas.component.html añadiremos en el html de la tarjeta una clase css llamada "puntero" que ya tenemos definida en nuestro archivo styles.css, esto hará que el puntero cambie cuando nos situemos sobre el elemento.

Vamos a añadir el evento click en el elemento, pero nosotros lo que manejamos en tarjetas es un "item", este item será a veces artistas y a veces canciones, en función de en qué página se cargue el componente de la tarjeta, si en el home o en el search, pero uno de los atributos de ese objeto es "type", que define esto, o bien "album" o "single" o "artist", lo cual nos servirá para discriminar en nuestro código si se trata de un artista, y entonces poder capturar el ID de ese elemento para poder enviarlo por la url posteriormente.

Así pues, en tarjetas.component.html incluiremos el evento (click) que ejecutará la funcion de verArtista( item ) al cual se le pasará el item, y posteriormente controlarermos ese item como hemos comentado.

```
<div class="row m-5 animated fadeIn">
    <div (click)="verArtista( item )" *ngFor="let item of items" class="card col-3 puntero">
        <img class="card-img-top" [src]="item.images | noimage">
        <div class="card-body">
            <h5 class="card-title">{{ item.name }}</h5>
            <p class="card-text">
                <span *ngFor="let artista of item.artists" class="badge rounded-pill bg-primary">{{ artista.name }}</span>
            </p>
        </div>
    </div>
</div>
```

Ahora en tarjetas.component.ts hacemos la lógica de la función, si al hacer click es de tipo artista guardaremos su ID, por el contrario iremos al primer artista del album o la canción y cogeremos su ID (NOTA PERSONAL: lo suyo sería pulirlo y añadir la funcion a cada artista en los badges, estamos definiendo esto para que coja algo, parece ser).

```
verArtista ( item: any ) {
    let artistaID;

    if ( item.type === 'artist' ) {
      artistaID = item.id;
    } else {
      artistaID = item.artists[0].id;
    }
    console.log(artistaID);

  }
```

Ahora solo nos falta redireccionar a la página del artista cuando hagamos click (en lugar de hacer console log como estamos haciendo). Para ello necesitamos importar el Router en el componente de tarjeta e inyectarlo en el constructor. Ahora podemos usar el metodo navigate de router para navegar, como recibe un parámetro la url se pone entre []. El primer parámetro es la ruta a la que quiero navegar (/artist) y el segundo el ID que le tengo que pasar a la url, artistID. Aún no tenemos definido el html del artista, pero ya funciona puesto que si hacemos click nos llevará a una url tipo `http://localhost:4200/#/artist/7Hd38PVp634oGEb9pIDs5d`. El código quedaría así de momento:

```
import { Component, Input } from '@angular/core';
import { Router } from '@angular/router';

@Component({
  selector: 'app-tarjetas',
  templateUrl: './tarjetas.component.html',
  styleUrls: ['./tarjetas.component.css']
})
export class TarjetasComponent {

  @Input() items: any[] = [];

  constructor( private router: Router ) { }

  verArtista ( item: any ) {
    let artistaID;

    if ( item.type === 'artist' ) {
      artistaID = item.id;
    } else {
      artistaID = item.artists[0].id;
    }
    
    this.router.navigate(['/artist', artistaID]);

  }

}
```

Vamos a definir la recepción del ID en el componente del artista, para así luego poder usarlo para ver su página. En artista.component.ts importamos ActivatedRoute de @angular/router y lo inyectamos en el constructor, esto nos permite que en el constructor podamos usar ActivatedRoute para suscribirnos/escuchar si hay cambios en la url, si se añaden parámetros, en este caso detectar si se está pasando el ID. De momento lo dejaremos para que podamos verlo por consola, el código quedaría tal que:

```
import { Component } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
@Component({
  selector: 'app-artista',
  templateUrl: './artista.component.html',
  styles: []
})
export class ArtistaComponent {

  constructor( private router: ActivatedRoute ) {

  this.router.params.subscribe( params => {
    console.log(params['id']);
  });

  }
}
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 106. Obtener artista de Spotify

Vamos a definir el servicio que nos permita recibir el artista, para ello antes de nada tendremo que volver a https://developer.spotify.com/console/artists/ para ver el endpoint que necesitamos, en este caso sería `https://api.spotify.com/v1/artists/{id}`

Vamos a reutilizar el código de getArtista, debió ser definido en su momento como getArtistas en plural, puesto que nos devuelve uno o varios artistas, y lo que queremos generar ahora es una función que nos devuelva uno solo y la llamaremos getArtista. Que en lugar de termino recibirá un id de tipo string.

Reutilizando el código lo único que deberemos modificar sería el string que recibe como argumento la función getQuery, quedando la función completada tal que:

```
getArtista( id: string ) {

    return this.getQuery(`artists/${id}`)
      .pipe( map( data => data['artists'].items ) );    
  }
```

Lo ideal sería saber qué es lo que nos devuelve el query, para poder validarlo correctamente o aplicar el map, para esto podríamos usar Postman, por ejemplo, en nuestro caso vamos a comentar la línea del .pipe(map) y a cerrar la función this.getQuery con punto y coma. Y vamos a ver qué devuelve el getQuery directamente desde nuestra aplicación de Angular.

```
getArtista( id: string ) {

    return this.getQuery(`artists/${id}`);
      //.pipe( map( data => data['artists'].items ) );    
  }
```

Volvemos a artista.component.ts, habíamos dejado definido que nos mostrase por consola el id de params, ya sabemos que se recibe correctamente, así que vamos a usar ese id para llamar al método getArtista y ver que información devuelve, vamos a crear un método aparte en el mismo componente que se llame también getArtista, que recibirá un id de tipo string, lo definiremos fuera del constructor para no sobrecargarlo de métodos, ese método llamará al servicio, por lo tanto necesitamos importarlo e inyectarlo en el componente, una vez hecho esto ya podemos llamar al servicio en la nueva función, el servicio llamará a la función getArtista pero a la del servicio, que recibirá el id y al cual nos suscribiremos para recibir la respuesta http.

Una vez hecho esto entonces en el ActivatedRoute del constructor ya podemos usar la escucha del id para pasarselo a la función getArtista como parámetro y así poder ver toda la información que nos devuelve del artista dado ese id.

Ahora en la consola tenemos toda la información relativa a ese artista, incluso una url externa que nos lleva al perfil del artista en Spotify  . Realmente ni haría falta filtrarlo por el map, puesto que ya nos devuelve un único objeto JSON muy ordenado y simple con un montón de información útil. Así que haremos un poco de maquetación html para mostrar la información de manera visualmente agradable, en lugar del "artista works!" :)

Por un lado vamos a maquetar un html, y por el lado del componente vamos a declarar una variable "artista" que sea un objeto vacío que usaremos para almacenar los datos que luego querremos renderizar en el html, recordamos que esta información la podemos manejar tal cual porque ya la recibimos de manera que podemos usarla sin problemas, si fuese complicado de acceder a los datos tendríamos que aplicar el pipe/map en el servicio. Entonces hasta aquí nuestro componente quedaría de esta manera:

```
import { Component } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { SpotifyService } from 'src/app/services/spotify.service';
@Component({
  selector: 'app-artista',
  templateUrl: './artista.component.html',
  styles: []
})
export class ArtistaComponent {

  artista: any = {};

  constructor( private router: ActivatedRoute,
               private spotify: SpotifyService ) {

  this.router.params.subscribe( params => {
    this.getArtista( params ['id']);
  });

  }

  getArtista( id: string ) {

    this.spotify.getArtista( id )
      .subscribe( artista => {
        console.log(artista);
        this.artista = artista;
      });
  }
}
```

Vamos a realizar una maquetación de la información. Incluiremos también el loading para que no nos tire un error de que tratar de cargar variables que aun no se encuentran cargadas, es decir, cuando se aplica el pipe en la imagen da error de que no encuentra dicha imagen, para ello declaramos una variable loadingArtist que haga de bandera y la incluimos en el constructor y en el observador de tal manera que obligamos a una pre-carga de los datos, a continuación, respectivamente, el código del componente actualizado y del html, respectivamente.

```
import { Component } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { SpotifyService } from 'src/app/services/spotify.service';
@Component({
  selector: 'app-artista',
  templateUrl: './artista.component.html',
  styles: []
})
export class ArtistaComponent {

  artista: any = {};
  loadingArtist: boolean;
  constructor( private router: ActivatedRoute,
               private spotify: SpotifyService ) {
                 this.loadingArtist = true;
  this.router.params.subscribe( params => {
    this.getArtista( params ['id']);
    
  });

  }

  getArtista( id: string ) {
    this.loadingArtist = true;
    this.spotify.getArtista( id )
      .subscribe( artista => {
        console.log(artista);
        this.artista = artista;
        this.loadingArtist = false;
        
      });
  }
}

```

```
<app-loading *ngIf="loadingArtist" class="m-5"></app-loading>
<div class="row animated fadeIn" *ngIf="!loadingArtist">

    <div class="col-2">
        <img [src]="artista.images | noimage" class="img-thumbnail img-circle" alt="">
    </div>

    <div class="col">
        <h3>{{ artista.name}}</h3>
        <p>
            <a [href]="artista.external_urls.spotify" target="_blank">Ir a la página del artista</a>
        </p>
    </div>

    <div class="col-4 text-right">
        <button routerLink="/search" class="btn btn-outline-danger">
            Regresar
        </button>
    </div>

</div>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 107. Servicio: Top-tracks

En esta sección vamos a trabajar usando las canciones más exitosas de un artista en particular. Usando el método `GET	/v1/artists/{id}/top-tracks` de la consola de Spotify for Developers, como hemos visto en otros ejemplos anteriores. Hasta ahora hemos hecho pruebas para ver cómo devuelve los datos el endpoint, para luego mapearlo o no, podemos usar Postman para esto también.

Primero vamos a crear un nuevo servicio para obtener esa información, vamos a usar como base uno de los que teníamos previamente, getArtista(). Recibirá un ID y actualizamos la parte del query para definir la cadena de endpoint que necesitamos en este caso. Lo útil de la función getQuery es que así podemos centralizar todas las peticiones al mismo servicio.

```
getTopTracks( id: string ) {

    return this.getQuery(`artists/${ id }/top-tracks`);
      //.pipe( map( data => data['artists'].items ) );    
  }
```

Guardamos cambios y vamos a artista.component.ts y creamos un método para llamar a ese servicio para obtener esa información, asimismo llamamos a la función en el constructor del componente para poder luego suscribirnos a él con el método.

```
                  this.getTopTracks( params ['id']);
```

```
getTopTracks( id: string ) {

    this.spotify.getTopTracks( id )
      .subscribe( topTracks => {
        console.log(topTracks)
      });
  }
```

Guardamos cambios y vemos que nos da un error, porque ese endpoint necesita como campo obligatorio el país, esto podríamos haberlo sabido antes si hubieramos hecho pruebas con Postman, como hemos mencionado anteriormente. Haciendo uso de la consola de Spotify Developer podemos deducir y ver que la url que requiere tiene como argumento el país, de tal manera que lo actualizamos en nuestro getQuery del servicio quedando `return this.getQuery(`artists/${ id }/top-tracks?country=us`);`

Ahora ya no nos da error y por el console.log que hicimos de los datos podemos ver que devuelve un objeto "tracks".

Nosotros en realidad queremos un array limpio con sólo las canciones, así que en este caso vamos a volver a utilizar el pipe map. Descomentamos el ejemplo que teníamos comentado resultado de haber copiado el método de getArtista, adaptándolo para que en lugar del objeto 'artist' filtre el objeto 'tracks'.

```
getTopTracks( id: string ) {

    return this.getQuery(`artists/${ id }/top-tracks?country=us`)
      .pipe( map( data => data['tracks'] ) );    
  }
```

Ahora podemos usar esos datos en nuestro componente, declaramos una nueva variable array que haga de contenedor `topTracks: any[] = [];` y podemos almacenar los datos suscritos en ella.

```
getTopTracks( id: string ) {

    this.spotify.getTopTracks( id )
      .subscribe( topTracks => {
        console.log(topTracks);
        this.topTracks = topTracks;
      });
  }
```

Aquí se nos pide una tarea, y es que en el artista.component.html se añada una maquetación con este esqueleto:

```
<div class="row">
        <div class="col">
            <table class="table">
                <thead>
                    <tr>
                        <th>Foto</th>
                        <th>Album</th>
                        <th>Canción</th>
                        <th>Vista Previa</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
```

La tarea consiste en tomar la información de los toptracks y llenar los campos de las celdas de la tabla (excepto foto y vista previa que se resolverá más adelante). Bastante sencillo, la solución era:

```
<tr *ngFor="let track of topTracks">
  <td></td>
  <td>{{ track.album.name }}</td>
  <td>{{ track.name }}</td>
  <td></td>
</tr>
```

Ahora vamos a trabajar con la fotografía, que es como hemos hecho anteriormente, [src] dinámico al que le pasamos la url de la imagen que es uno de los argumentos del array, le pasaremos el pipe personalizado no-image por si hubiera algún problema. También añadiremos una clase css img-thumb que ya viene definida en el archivo styles.css de la lección, que lo reduce a 50px de alto y ancho, porque del servicio vienen con mucha resolución.

```
<img [src]="track.album.images | noimage" [alt]="track.album.name" class="img-thumb">
```

Por último vamos a añadir una vista previa, en el array ya hay una propiedad que es "preview-url" que usaremos para esto.

NOTA: por un lado he descubierto que el endpoint está obsoleto aunque sigue funcionando, ahora es "markets" en lugar de "country", siendo la query así: `return this.getQuery(`artists/${ id }/top-tracks?market=US`)` por otro lado hay mucho casos en el que no hay preview_url y devuelve null, así que añadiré yo un arreglo a la maquetación para controlar que no de error con un *ngIf, nótese en el código html final del ejercicio. Realmente no da error interno de la app ese null, pero añadí información con un span.

Así pues, con una etiqueta de HTML5 que se llama audio haremos la llamada a la url de la canción para el reproductor. El atributo de la etiqueta 'controls' incluye los controles de play, descargar, etc.

El código final, hasta el momento, sería:

```
<div class="row m-5">
        <div class="col">
            <table class="table">
                <thead>
                    <tr>
                        <th>Foto</th>
                        <th>Album</th>
                        <th>Canción</th>
                        <th>Vista Previa</th>
                    </tr>
                </thead>
                <tbody>
                    <tr *ngFor="let track of topTracks">
                        <td>
                            <img [src]="track.album.images | noimage" [alt]="track.album.name" class="img-thumb">
                        </td>
                        <td>{{ track.album.name }}</td>
                        <td>{{ track.name }}</td>
                        <td>
                            <audio [src]="track.preview_url" controls></audio><br>
                            <span *ngIf="!track.preview_url">Vista previa no disponible</span>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 108. Widgets de Spotify

En esta sección cambiaremos la etiqueta audio del ejercicio anterior por un widget de Spotify. El widget necesita una app de Spotify conectada y funcionando, para poder funcionar en la app. Tiramos de documentación: `https://developer.spotify.com/documentation/widgets/` Adding a Widget -> Standard HTML Pages -> Embed `https://developer.spotify.com/documentation/widgets/generate/embed/` , es incluir un iframe... no tiene mucho más, selecionamos modo compacto y poco más, usamos el iframe de ejemplo que viene y lo ponemos tal cual en nuestro html para ver el efecto.

`<iframe src="https://open.spotify.com/embed/album/1DFixLWuPkv3KT3TnV35m3" width="300" height="80" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe>`

`<iframe src="https://open.spotify.com/embed?uri=spotify:album:1DFixLWuPkv3KT3TnV35m3" width="300" height="80" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe>`

NOTA: Se ve que se actualizó la manera y el endpoint puede ser de distintas maneras, seguiré la del profesor, aunque se puede hacer como la primera versión que puse, la segunda también funciona.

Como vimos en la sección de pipes, es posible que nos de error al tratar de generar la url dinámicamente, tratándola como no segura, en los recursos de esta sección se añadió el archivo typescript del pipe para incluirlo (o cogerlo de la versión anterior del proyecto.) Lo copiamos al directorio pipes del proyecto y lo importamos en el app.module.ts para que funcione (import y declaración).

Ahora podemos filtrar con el pipe la url de esta manera:`<iframe [src]="track.uri | domseguro:'https://open.spotify.com/embed?uri=' " width="300" height="80" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe>`

El problema es que se ve muy engorroso, porque el pipe original customizado lo que hacía era componer la cadena de url cogiendo un valor y la propia cadena y concatenándolos, pero como ese pipe lo vamos a usar para este proyecto lo vamos a personalizar, alterando el pipe y definiendo la cadena que no cambia (el principio de la url) como constante, de esa manera quedará mucho más limpio, en el domseguro.pipe.ts:

```
transform( value: string): any {
    const url = 'https://open.spotify.com/embed?uri=';
    return this.domSanitizer.bypassSecurityTrustResourceUrl( url + value );
  }
```

Y ahora en el html queda mucho más sencillo:

```
<td>
    <!-- <audio [src]="track.preview_url" controls></audio><br> -->
    <iframe [src]="track.uri | domseguro" width="300" height="80" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe>
    <span *ngIf="!track.preview_url">Vista previa no disponible</span>
</td>
```

[Volver al Índice](#%C3%ADndice-del-curso)

## 109. Manejo de errores de un observable

En esta clase manejaremos algunos errores, supongamos que el token de Spotify expira, se hace una petición mal, cualquier cosa.

Vamos a poner una caja de texto en el home para simular un error.(home.component.html). Lo dejaremos así, pero podríamos crear un componente sólo para esto y otros métodos de control de errores.

```
<app-loading *ngIf="loading"></app-loading>
<div class="alert alert-danger">
    <h3>Error</h3>
    <p>Hola Mundo</p>
</div>
<app-tarjetas [items]="nuevasCanciones"></app-tarjetas>
```

La idea es declarar en el componente home una variable booleana 'error' para luego mediante un *ngIf en el frontal poder controlar la bandera.

En el componente temenos la función getNewReleases() la cual tiene un subscribe, le podemos pasar una nueva funcion de flecha como argumento para que reciba esa variable de error (es un argumento opcional del método subscribe). Así podremos identificar que tipo de error nos devuelve la API (en este caso la de Spotify, pero cambiará para las distintas API que usemos en el futuro.)Con los console log podemos ver el objeto de error y que parámetros tiene para así poder acceder a la info que nos interese, por ejemplo el mensaje de error "errorServicio.error.error.message"

```
constructor( private spotify: SpotifyService) {

    this.loading = true;

    this.spotify.getNewReleases()
    .subscribe( (data: any) => {
      this.nuevasCanciones = data;
      this.loading = false;
    }, (errorServicio) => {
      this.loading = false;
      this.error = true;
      console.log(errorServicio.error.error.message);
    });
  }
```

Podemos declarar en el componente una variable string que nos sirva para almacenar ese mensaje de error mensajeError: string;

Quedando el html:

```
<app-loading *ngIf="loading"></app-loading>
<div *ngIf="error" class="alert alert-danger animated fadeIn">
    <h3>Error</h3>
    <p>{{ mensajeError }}</p>
</div>
<app-tarjetas [items]="nuevasCanciones"></app-tarjetas>
```

Y el componente:

```
import { Component, OnInit } from '@angular/core';
import { SpotifyService } from '../../services/spotify.service';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html'
})
export class HomeComponent {

  nuevasCanciones: any[] = [];
  loading: boolean;
  error: boolean = false;
  mensajeError: string;

  constructor( private spotify: SpotifyService) {

    this.loading = true;

    this.spotify.getNewReleases()
    .subscribe( (data: any) => {
      this.nuevasCanciones = data;
      this.loading = false;
    }, (errorServicio) => {
      this.loading = false;
      this.error = true;
      this.mensajeError = errorServicio.error.error.message;
    });
  }

  ngOnInit(): void {
  }

}

```

[Volver al Índice](#%C3%ADndice-del-curso)

## 110. Generar Token de Spotify de forma automática

La API de Spotify solo permite peticiones POST desde un servidor, por eso podemos hacerla desde Postman (que monta su propio servidor) y luego nos hemos visto obligados a añadirla manualmente como una constante.

En el curso no se da detalle, probaré a hacerlo personalmente, pero básicamente monta en un servidor cloud (Heroku) una app que genera el token. Lo probaré.

[Volver al Índice](#%C3%ADndice-del-curso)

## Cuestionario 3: Examen teórico: SpotiApp

8 de 8 Acertadas! :D

[Volver al Índice](#%C3%ADndice-del-curso)

## 111. Código fuente de la sección

Código fuente:

Pueden descargar el código fuente de la sección del material adjunto.

Si tienen curiosidad de como hice el backend para obtener el token, puede descargar el código aquí

https://github.com/Klerith/spotify-get-token

Nota:

Tengo un curso de Node que puede ser un excelente complemento para este curso de Angular, si lo desean, aquí les dejo el enlace

Curso de Node - Descuento para estudiantes

Espero que esta aplicación les gustara mucho!, los veo en el siguiente video

[Volver al Índice](#%C3%ADndice-del-curso)
